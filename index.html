<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Mapa de Aldeas</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  height: 100vh;
  overflow: hidden;
  background-color: #4da6ff;
  font-family: sans-serif;
  transition: background-color 0.5s ease;
}
body.night-mode { background-color: #1a1a2e; }
.map-view, .island-view {
  position: absolute;
  width: 100%;
  height: 100%;
  transition: opacity 0.4s ease;
}
.island-view {
  opacity: 0;
  pointer-events: none;
  background-color: #4da6ff;
}
body.night-mode .island-view { background-color: #1a1a2e; }
.map-view::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 20, 0);
  pointer-events: none;
  transition: background 0.5s ease;
  z-index: 1;
}
body.night-mode .map-view::before { background: rgba(0, 0, 20, 0.6); }
.viewport {
  width: 100%;
  height: 100%;
  overflow: hidden;
  position: relative;
  cursor: grab;
}
.world {
  position: absolute;
  transform-origin: 0 0;
  width: 100%;
  height: 100%;
}
.grid {
  position: absolute;
  display: grid;
  grid-template-columns: repeat(50, 40px);
  grid-template-rows: repeat(50, 40px);
  gap: 2px;
  background-color: #4da6ff;
  padding: 200px;
  transition: background-color 0.5s ease;
}
body.night-mode .grid { background-color: #1a1a2e; }
.grid.no-grid { gap: 0px; }
.grid.island {
  grid-template-columns: repeat(20, 40px);
  grid-template-rows: repeat(20, 40px);
}
.cell {
  width: 40px;
  height: 40px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 18px;
  color: white;
  font-weight: bold;
  border-radius: 4px;
  user-select: none;
  cursor: pointer;
  position: relative;
}
.grid.no-grid .cell { border-radius: 0px; }
.cell .owner-name {
  position: absolute;
  bottom: 100%;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0, 0, 0, 0.8);
  color: white;
  padding: 4px 8px;
  border-radius: 4px;
  font-size: 12px;
  white-space: nowrap;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.2s;
  margin-bottom: 5px;
  z-index: 100;
}
.cell:hover .owner-name { opacity: 1; }
.grass {
  background-color: #4CAF50;
  transition: background-color 0.5s ease;
}
body.night-mode .grass { background-color: #2d5016; }

/* Texturas de pasto */
body.texture-mode .grass {
  background-image: url('recursos/pasto.png');
  background-size: cover;
  background-position: center;
  background-repeat: no-repeat;
}
body.texture-mode.night-mode .grass {
  background-image: url('recursos/pasto.png');
  filter: brightness(0.6);
}
.road {
  background-color: #A1887F;
  transition: background-color 0.5s ease;
}
body.night-mode .road { background-color: #5d4e42; }
.mountain {
  background-color: #9E9E9E;
  transition: background-color 0.5s ease;
}
body.night-mode .mountain { background-color: #4a4a4a; }
.building {
  background-color: #8B4513;
  cursor: pointer;
  transition: transform 0.3s ease;
}
.building:hover { transform: scale(1.2); }
.wall { background-color: #9E9E9E; }
.gold-mine {
  background-color: #FFD700;
  color: #000;
}
body.night-mode .gold-mine { background-color: #b39700; }
.rocket-launcher, .statue, .flower, .deflector-tower {
  background-color: #666;
  color: white;
}
body.night-mode .rocket-launcher, body.night-mode .statue, body.night-mode .flower, body.night-mode .deflector-tower { background-color: #444; }
.deflector-tower {
  background-color: #00CED1;
  color: white;
  animation: deflectorPulse 2s infinite;
}
body.night-mode .deflector-tower { background-color: #008B8B; }
@keyframes deflectorPulse {
  0%, 100% { box-shadow: 0 0 5px #00CED1; }
  50% { box-shadow: 0 0 15px #00CED1, 0 0 25px #00CED1; }
}
.aa-turret {
  background-color: #FF6347;
  color: white;
  animation: aaTurretPulse 1.5s infinite;
}
body.night-mode .aa-turret { background-color: #8B0000; }
@keyframes aaTurretPulse {
  0%, 100% { box-shadow: 0 0 5px #FF6347; }
  50% { box-shadow: 0 0 15px #FF6347, 0 0 25px #FF4500; }
}
@keyframes splashAnimation {
  0% { transform: scale(0.5); opacity: 1; }
  50% { transform: scale(1.5); opacity: 0.8; }
  100% { transform: scale(2); opacity: 0; }
}
/* Notificaci√≥n flotante estilo COD */
.xp-notification {
  position: fixed;
  font-size: 32px;
  font-weight: bold;
  color: #FFD700;
  text-shadow: 
    0 0 10px rgba(255, 215, 0, 0.8),
    0 0 20px rgba(255, 215, 0, 0.6),
    2px 2px 4px rgba(0, 0, 0, 0.8);
  z-index: 10005;
  pointer-events: none;
  animation: xpFloat 2s ease-out forwards;
  font-family: 'Arial Black', sans-serif;
  letter-spacing: 2px;
}
@keyframes xpFloat {
  0% {
    transform: translateY(0) scale(1);
    opacity: 1;
  }
  20% {
    transform: translateY(-30px) scale(1.2);
    opacity: 1;
  }
  100% {
    transform: translateY(-120px) scale(0.8);
    opacity: 0;
  }
}
.flower {
  background-color: #90EE90;
  color: white;
}
body.night-mode .flower { background-color: #4a7c4a; }
.damaged {
  background-color: #8B4513;
}
body.night-mode .damaged { background-color: #5d2e0b; }
/* Terreno destruido en modo texturas */
body.texture-mode .damaged {
  background-image: url('recursos/terrenodestruido.png');
  background-size: cover;
  background-position: center;
  background-repeat: no-repeat;
}
body.texture-mode.night-mode .damaged {
  filter: brightness(0.6);
}
.center {
  background-color: #8B4513;
}
body.night-mode .center { background-color: #5d2e0b; }

/* Colores de fondo para castillos en mapa principal */
.map-view .my-castle {
  background-color: #4169E1;
}
.map-view .enemy-castle {
  background-color: #DC143C;
}
body.night-mode .map-view .my-castle {
  background-color: #1E3A8A;
}
body.night-mode .map-view .enemy-castle {
  background-color: #7F1D1D;
}
.destroyed-castle {
  background-color: #2d2d2d !important;
  animation: destroyed-pulse 2s ease-in-out infinite;
}
body.night-mode .destroyed-castle {
  background-color: #1a1a1a !important;
}
@keyframes destroyed-pulse {
  0%, 100% { opacity: 0.7; }
  50% { opacity: 1; }
}

/* Barras de vida para estructuras */
.health-bar-container {
  position: absolute;
  top: -8px;
  left: 50%;
  transform: translateX(-50%);
  width: 90%;
  height: 6px;
  background-color: rgba(0, 0, 0, 0.5);
  border-radius: 3px;
  overflow: hidden;
  z-index: 10;
  border: 1px solid rgba(255, 255, 255, 0.3);
}
.health-bar {
  height: 100%;
  background: linear-gradient(90deg, #4CAF50, #8BC34A);
  transition: width 0.3s ease, background 0.3s ease;
  border-radius: 2px;
}
.health-bar.medium {
  background: linear-gradient(90deg, #FFA726, #FFB74D);
}
.health-bar.low {
  background: linear-gradient(90deg, #EF5350, #E57373);
}
.health-text {
  position: absolute;
  top: -20px;
  left: 50%;
  transform: translateX(-50%);
  font-size: 10px;
  font-weight: bold;
  color: white;
  text-shadow: 0 0 3px rgba(0,0,0,0.8);
  white-space: nowrap;
  z-index: 11;
  pointer-events: none;
}

/* Texturas de castillos - SOLO en modo texturas */
body.texture-mode .my-castle {
  background-image: url('recursos/castilloblue.png');
  background-size: cover;
  background-position: center;
  background-repeat: no-repeat;
  font-size: 0;
  color: transparent;
}
body.texture-mode .enemy-castle {
  background-image: url('recursos/castillored.png');
  background-size: cover;
  background-position: center;
  background-repeat: no-repeat;
  font-size: 0;
  color: transparent;
}
/* Castillo da√±ado (menos del 50% HP) */
body.texture-mode .my-castle.castle-damaged,
body.texture-mode .enemy-castle.castle-damaged {
  background-image: url('recursos/castillomitad.png');
}
/* Castillo destruido */
body.texture-mode .destroyed-castle {
  background-image: url('recursos/castillodestroy.png');
  background-size: cover;
  background-position: center;
  background-repeat: no-repeat;
  font-size: 0;
  color: transparent;
}
body.texture-mode.night-mode .my-castle,
body.texture-mode.night-mode .enemy-castle,
body.texture-mode.night-mode .destroyed-castle {
  filter: brightness(0.6);
}
.particula {
  position: absolute;
  width: 8px;
  height: 8px;
  background: red;
  border-radius: 50%;
  opacity: 1;
  animation: subir 1.5s linear forwards;
  box-shadow: 0 0 10px rgba(255, 0, 0, 0.8), 0 0 20px rgba(255, 100, 0, 0.6);
  filter: brightness(1.5);
}
@keyframes subir {
  0% {
    transform: translateY(0) scale(1);
    opacity: 1;
  }
  100% {
    transform: translateY(-80px) scale(0.5);
    opacity: 0;
  }
}
.explosion-particle {
  position: absolute;
  width: 8px;
  height: 8px;
  border-radius: 50%;
  pointer-events: none;
  z-index: 10001;
}
@keyframes explode {
  0% {
    transform: translate(0, 0) scale(1);
    opacity: 1;
  }
  100% {
    opacity: 0;
  }
}
@keyframes shake {
  0%, 100% { transform: translate(0, 0); }
  10%, 30%, 50%, 70%, 90% { transform: translate(-10px, -10px); }
  20%, 40%, 60%, 80% { transform: translate(10px, 10px); }
}
.shake {
  animation: shake 0.5s ease-in-out;
}
.btn {
  position: fixed;
  padding: 12px 20px;
  background: white;
  border: none;
  border-radius: 8px;
  box-shadow: 0 2px 10px rgba(0,0,0,0.3);
  cursor: pointer;
  font-size: 14px;
  font-weight: bold;
  z-index: 1000;
  transition: background 0.3s, transform 0.3s;
}
.btn:hover { background: #f0f0f0; }
.btn.primary {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  font-size: 18px;
  padding: 15px 30px;
  border-radius: 10px;
  box-shadow: 0 4px 15px rgba(0,0,0,0.3);
}
.btn.primary:hover {
  transform: scale(1.05);
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
}
.btn.danger {
  background: linear-gradient(135deg, #ff0000 0%, #8b0000 100%);
}
.btn.gold {
  background: linear-gradient(135deg, #ffd89b 0%, #19547b 100%);
}
.btn.success {
  background: linear-gradient(135deg, #89ff00 0%, #00bcd4 100%);
}
.btn.pink {
  background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
}
#gridToggle { top: 20px; right: 20px; }
#logoutButton { top: 70px; right: 20px; }
#dayNightToggle { top: 120px; right: 20px; font-size: 24px; }
#backButton { bottom: 20px; left: 20px; font-size: 16px; }
#islandGridToggle { bottom: 70px; left: 20px; opacity: 0; pointer-events: none; }
#islandTextureToggle { 
  bottom: 200px; 
  right: 20px; 
  opacity: 0; 
  pointer-events: none;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  font-size: 18px;
  padding: 15px 30px;
  border-radius: 10px;
  box-shadow: 0 4px 15px rgba(0,0,0,0.3);
}
#islandTextureToggle:hover {
  transform: scale(1.05);
}
#islandAchievementsButton { bottom: 140px; right: 20px; opacity: 0; pointer-events: none; }
#shopButton, #inventoryButton, #marketButton, #attackButton, #achievementsButton { bottom: 20px; right: 20px; display: none; }
#inventoryButton { bottom: 80px; }
#marketButton { bottom: 260px; }
#achievementsButton { bottom: 320px; }
#attackButton { bottom: 380px; }
#globalShopButton { bottom: 80px; right: 20px; }
#topPlayersButton { bottom: 20px; right: 20px; }
.panel {
  position: absolute;
  background: rgba(0, 0, 0, 0.7);
  padding: 15px 20px;
  border-radius: 10px;
  color: white;
  z-index: 100;
  box-shadow: 0 4px 15px rgba(0,0,0,0.5);
  display: none;
}
#resourcesPanel { top: 20px; right: 20px; font-size: 20px; font-weight: bold; }
#userInfoPanel { top: 20px; left: 20px; min-width: 250px; }
#userInfoPanel h3 { margin: 0 0 10px 0; font-size: 18px; }
#levelInfo { font-size: 16px; margin-bottom: 8px; }
#xpBarContainer {
  background: rgba(255, 255, 255, 0.2);
  height: 20px;
  border-radius: 10px;
  overflow: hidden;
  margin-top: 5px;
  position: relative;
}
#xpBar {
  background: linear-gradient(90deg, #4CAF50, #8BC34A);
  height: 100%;
  width: 0%;
  transition: width 0.5s ease;
}
#xpBarText {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 12px;
  font-weight: bold;
  color: white;
  text-shadow: 0 0 3px rgba(0,0,0,0.5);
  white-space: nowrap;
}
#goldCapacityBarContainer {
  background: rgba(255, 255, 255, 0.2);
  height: 8px;
  border-radius: 4px;
  overflow: hidden;
  position: relative;
}
#goldCapacityBar {
  background: linear-gradient(90deg, #FFD700, #FFA500);
  height: 100%;
  width: 0%;
  transition: width 0.5s ease;
  box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
}
#goldCapacityBar.full {
  background: linear-gradient(90deg, #ff4444, #cc0000);
  animation: pulse-red 1.5s ease-in-out infinite;
}
@keyframes pulse-red {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.6; }
}
#islandTitle {
  position: absolute;
  top: 20px;
  left: 50%;
  transform: translateX(-50%);
  color: white;
  font-size: 2em;
  text-shadow: 0 0 20px rgba(0,0,0,0.8);
  z-index: 100;
}
.modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.8);
  display: none;
  justify-content: center;
  align-items: center;
  z-index: 10000;
}
.modal-content {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  padding: 30px;
  border-radius: 20px;
  max-width: 500px;
  width: 90%;
  max-height: 80vh;
  overflow-y: auto;
  box-shadow: 0 10px 50px rgba(0,0,0,0.5);
  position: relative;
}
.modal-content.large { max-width: 600px; }
.modal-content.small { max-width: 400px; }
.modal-content.fullscreen {
  max-width: 100%;
  width: 100%;
  height: 100vh;
  max-height: 100vh;
  padding: 50px;
  border-radius: 0;
  background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
  overflow-y: auto;
}
.modal-content h2 {
  color: white;
  margin: 0 0 20px 0;
  text-align: center;
  font-size: 28px;
}
.shop-item, .top-player-item, .achievement-item {
  background: rgba(255, 255, 255, 0.9);
  padding: 15px 20px;
  margin: 10px 0;
  border-radius: 10px;
  display: flex;
  align-items: center;
  gap: 15px;
}
.shop-item { justify-content: space-between; padding: 20px; }
.shop-tabs {
  display: flex;
  gap: 10px;
  margin-bottom: 20px;
  border-bottom: 2px solid rgba(255,255,255,0.2);
  padding-bottom: 10px;
}
.shop-tab {
  flex: 1;
  padding: 12px 20px;
  background: rgba(255,255,255,0.1);
  border: none;
  border-radius: 8px 8px 0 0;
  color: white;
  font-size: 16px;
  font-weight: bold;
  cursor: pointer;
  transition: all 0.3s;
}
.shop-tab:hover {
  background: rgba(255,255,255,0.2);
  transform: translateY(-2px);
}
.shop-tab.active {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
}
.shop-category {
  display: none;
}
.shop-category.active {
  display: block;
}
.top-player-item { cursor: pointer; transition: transform 0.2s, background 0.2s; }
.top-player-item:hover {
  transform: translateX(5px);
  background: rgba(255, 255, 255, 1);
}
.achievement-item.unlocked {
  background: rgba(76, 175, 80, 0.2);
  border: 2px solid #4CAF50;
}
.shop-item-info, .top-player-info, .achievement-info { flex: 1; }
.shop-item-name, .top-player-name, .achievement-name {
  font-size: 18px;
  font-weight: bold;
  color: #333;
}
.shop-item-desc, .top-player-stats, .achievement-desc {
  font-size: 14px;
  color: #666;
  margin-top: 3px;
}
.shop-item-cost {
  font-size: 16px;
  color: #FFD700;
  font-weight: bold;
}
.shop-item button, .attack-option {
  padding: 10px 20px;
  background: #4CAF50;
  border: none;
  border-radius: 8px;
  color: white;
  font-weight: bold;
  cursor: pointer;
  font-size: 16px;
  transition: background 0.3s;
}
.shop-item button:hover { background: #45a049; }
.shop-item button:disabled {
  background: #ccc;
  cursor: not-allowed;
}
.attack-option {
  display: block;
  width: 100%;
  margin: 10px 0;
  padding: 15px;
  background: rgba(255, 255, 255, 0.9);
  color: #333;
}
.modal-close {
  display: block;
  margin: 20px auto 0;
  padding: 12px 30px;
  background: rgba(255, 255, 255, 0.2);
  border: 2px solid white;
  border-radius: 8px;
  color: white;
  font-weight: bold;
  cursor: pointer;
  font-size: 16px;
}
.modal-close:hover { background: rgba(255, 255, 255, 0.3); }
.modal-close-top-left {
  position: absolute;
  top: 20px;
  right: 20px;
  width: 50px;
  height: 50px;
  background: rgba(255, 0, 0, 0.8);
  border: 3px solid white;
  border-radius: 50%;
  color: white;
  font-weight: bold;
  cursor: pointer;
  font-size: 28px;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 10001;
  transition: all 0.3s;
  margin: 0;
  padding: 0;
  line-height: 1;
}
.modal-close-top-left:hover {
  background: rgba(255, 0, 0, 1);
  transform: scale(1.1);
  box-shadow: 0 0 20px rgba(255, 0, 0, 0.6);
}
.login-tabs {
  display: flex;
  gap: 10px;
  margin-bottom: 20px;
}
.tab-button {
  flex: 1;
  padding: 12px;
  background: rgba(255, 255, 255, 0.2);
  border: none;
  border-radius: 8px;
  color: white;
  font-weight: bold;
  cursor: pointer;
  font-size: 16px;
  transition: background 0.3s;
}
.tab-button.active { background: rgba(255, 255, 255, 0.4); }
.tab-button:hover { background: rgba(255, 255, 255, 0.3); }
.login-form {
  display: none;
}
.login-form.active { display: block; }
.form-group {
  margin-bottom: 20px;
}
.form-group label {
  display: block;
  color: white;
  margin-bottom: 8px;
  font-weight: bold;
}
.form-group input {
  width: 100%;
  padding: 12px;
  border: none;
  border-radius: 8px;
  font-size: 16px;
  box-sizing: border-box;
}
.form-group input:focus { outline: 2px solid white; }
.login-button {
  width: 100%;
  padding: 15px;
  background: #4CAF50;
  border: none;
  border-radius: 8px;
  color: white;
  font-weight: bold;
  cursor: pointer;
  font-size: 18px;
  transition: background 0.3s;
}
.login-button:hover { background: #45a049; }
.error-message {
  color: #ffcccc;
  background: rgba(255, 0, 0, 0.2);
  padding: 10px;
  border-radius: 5px;
  margin-top: 15px;
  text-align: center;
  display: none;
}
.tutorial-step {
  display: none;
  color: white;
}
.tutorial-step.active { display: block; }
.tutorial-icon {
  font-size: 80px;
  margin: 20px 0;
}
.tutorial-text {
  font-size: 18px;
  line-height: 1.6;
  margin: 20px 0;
}
.tutorial-buttons {
  display: flex;
  gap: 15px;
  margin-top: 30px;
  justify-content: center;
}
.tutorial-button {
  padding: 15px 30px;
  border: none;
  border-radius: 8px;
  font-size: 16px;
  font-weight: bold;
  cursor: pointer;
  transition: transform 0.2s;
}
.tutorial-button:hover { transform: scale(1.05); }
.tutorial-button.primary {
  background: #4CAF50;
  color: white;
}
.tutorial-button.secondary {
  background: rgba(255, 255, 255, 0.2);
  color: white;
  border: 2px solid white;
}
.tutorial-progress {
  color: rgba(255, 255, 255, 0.7);
  margin-top: 20px;
  font-size: 14px;
}
.top-player-rank {
  font-size: 24px;
  font-weight: bold;
  width: 40px;
  text-align: center;
}
.top-player-rank.first { color: #FFD700; }
.top-player-rank.second { color: #C0C0C0; }
.top-player-rank.third { color: #CD7F32; }
.top-player-xp {
  font-size: 16px;
  font-weight: bold;
  color: #4CAF50;
}
.achievement-icon {
  font-size: 40px;
  min-width: 50px;
  text-align: center;
}
.achievement-reward {
  font-size: 12px;
  color: #4CAF50;
  font-weight: bold;
  margin-top: 5px;
}
.achievement-status {
  font-size: 16px;
  font-weight: bold;
  color: #4CAF50;
}
.achievement-status.locked { color: #999; }
#fade {
  position: absolute;
  width: 100%;
  height: 100%;
  background-color: black;
  opacity: 0;
  transition: opacity 0.4s ease;
  pointer-events: none;
  z-index: 9999;
}
#loading {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(0, 0, 0, 0.8);
  color: white;
  padding: 20px 40px;
  border-radius: 10px;
  font-size: 18px;
  z-index: 10000;
  display: none;
}
</style>
</head>
<body>
<div class="map-view">
  <div class="viewport" id="mainViewport">
    <div class="world" id="mainWorld">
      <div class="grid" id="mainGrid"></div>
    </div>
  </div>
  <button class="btn" id="gridToggle">Quitar Cuadr√≠cula</button>
  <button class="btn" id="logoutButton">Cerrar Sesi√≥n</button>
  <button class="btn" id="dayNightToggle">üåô</button>
  <button class="btn gold primary" id="achievementsButton">üèÜ Logros</button>
  <button class="btn success primary" id="globalShopButton">üåê Tienda Global</button>
  <button class="btn pink primary" id="topPlayersButton">üèÜ Top Jugadores</button>
</div>
<div class="island-view">
  <button class="btn" id="backButton">‚Üê Volver al Mapa</button>
  <button class="btn" id="islandGridToggle">Quitar Cuadr√≠cula</button>
  <button class="btn" id="islandTextureToggle">üé® Texturas</button>
  <button class="btn gold primary" id="islandAchievementsButton">üèÜ Logros</button>
  <div id="islandTitle">Aldea de <span id="ownerName"></span></div>
  <div class="panel" id="userInfoPanel">
    <h3 id="userName"></h3>
    <div id="levelInfo">Nivel: <span id="userLevel">1</span></div>
    <div id="xpBarContainer">
      <div id="xpBar"></div>
      <div id="xpBarText">0 / 100 XP</div>
    </div>
  </div>
  <div class="panel" id="resourcesPanel">
    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 5px;">
      üí∞<span id="goldAmount">0</span> / <span style="color: #FFD700;">10,000</span>
    </div>
    <div id="goldCapacityBarContainer">
      <div id="goldCapacityBar"></div>
    </div>
  </div>
  <button class="btn primary" id="shopButton">üõí Tienda</button>
  <button class="btn primary" id="inventoryButton">üéí Inventario</button>
  <button class="btn success primary" id="marketButton">üé™ Mercado</button>
  <button class="btn danger primary" id="attackButton">‚öîÔ∏è Atacar</button>
  <div class="viewport" id="islandViewport">
    <div class="world" id="islandWorld">
      <div class="grid island" id="islandGrid"></div>
    </div>
  </div>
</div>
<div class="modal" id="shopModal">
  <div class="modal-content">
    <h2>üõí Tienda</h2>
    <div class="shop-item">
      <div class="shop-item-info">
        <div class="shop-item-name">‚õèÔ∏è Mina de Oro</div>
        <div class="shop-item-desc">Genera 10 de oro cada 5 segundos</div>
        <div class="shop-item-desc">Tienes: <span id="mineCount">0</span> / 2</div>
        <div class="shop-item-cost">üí∞ 50 Oro</div>
      </div>
      <button id="buyMineBtn">Comprar</button>
    </div>
    <div class="shop-item">
      <div class="shop-item-info">
        <div class="shop-item-name">üöÄ Lanza Cohetes</div>
        <div class="shop-item-desc">Estructura avanzada para ataques de cohetes</div>
        <div class="shop-item-desc">Tienes: <span id="rocketLauncherCount">0</span> / 1</div>
        <div class="shop-item-cost">üí∞ 2000 Oro</div>
      </div>
      <button id="buyRocketLauncherBtn">Comprar</button>
    </div>
    <div class="shop-item">
      <div class="shop-item-info">
        <div class="shop-item-name">üóº Torreta Anti-A√©rea</div>
        <div class="shop-item-desc">Derriba aviones bombarderos enemigos</div>
        <div class="shop-item-desc">Tienes: <span id="aaTurretCount">0</span> / 2</div>
        <div class="shop-item-cost">üí∞ 1800 Oro</div>
      </div>
      <button id="buyAATurretBtn">Comprar</button>
    </div>
    <div class="shop-item">
      <div class="shop-item-info">
        <div class="shop-item-name">üõ†Ô∏è Pala</div>
        <div class="shop-item-desc">Repara √°reas da√±adas en tu aldea</div>
        <div class="shop-item-desc" style="margin-top: 8px;">
          <strong>Nivel de reparaci√≥n:</strong>
          <div style="display: flex; gap: 5px; margin-top: 5px;">
            <button class="shovel-level-btn active" data-level="1" style="padding: 8px 15px; border: 2px solid #4CAF50; background: white; border-radius: 5px; cursor: pointer; font-weight: bold; color: #333; font-size: 14px;">x1</button>
            <button class="shovel-level-btn" data-level="5" style="padding: 8px 15px; border: 2px solid #ccc; background: white; border-radius: 5px; cursor: pointer; color: #333; font-size: 14px;">x5</button>
            <button class="shovel-level-btn" data-level="10" style="padding: 8px 12px; border: 2px solid #ccc; background: white; border-radius: 5px; cursor: pointer; color: #333; font-size: 14px;">x10</button>
            <button class="shovel-level-btn" data-level="15" style="padding: 8px 12px; border: 2px solid #ccc; background: white; border-radius: 5px; cursor: pointer; color: #333; font-size: 14px;">x15</button>
            <button class="shovel-level-btn" data-level="25" style="padding: 8px 12px; border: 2px solid #ccc; background: white; border-radius: 5px; cursor: pointer; color: #333; font-size: 14px;">x25</button>
          </div>
        </div>
        <div class="shop-item-cost" id="shovelCost">üí∞ 50 Oro</div>
      </div>
      <button id="buyShovelBtn">Comprar</button>
    </div>
    <button class="modal-close" id="closeShop">Cerrar</button>
  </div>
</div>
<div class="modal" id="inventoryModal">
  <div class="modal-content">
    <h2>üéí Inventario</h2>
    <div id="inventoryItems"></div>
    <button class="modal-close" id="closeInventory">Cerrar</button>
  </div>
</div>
<div class="modal" id="marketModal">
  <div class="modal-content fullscreen">
    <button class="modal-close-top-left" id="closeMarket">‚úï</button>
    <h2>üé™ Mercado de Jugadores</h2>
    <div style="text-align: center; margin-bottom: 20px; color: #666;">
      üí∞ Tu Oro: <span id="marketGold" style="color: #FFD700; font-weight: bold;">0</span>
    </div>
    <div class="shop-tabs">
      <button class="shop-tab active" data-tab="market-buy">üõí Comprar</button>
      <button class="shop-tab" data-tab="market-sell">üí∞ Vender</button>
      <button class="shop-tab" data-tab="market-my">üì¶ Mis Ofertas</button>
    </div>
    
    <!-- COMPRAR -->
    <div class="shop-category active" id="market-buy">
      <div style="margin-bottom: 15px;">
        <input type="text" id="marketSearchBuy" placeholder="üîç Buscar objetos..." style="width: 100%; padding: 10px; border: 2px solid #ddd; border-radius: 5px; font-size: 14px;">
      </div>
      <div id="marketBuyList" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 15px; max-height: 500px; overflow-y: auto;">
        <!-- Ofertas de compra se cargar√°n aqu√≠ -->
      </div>
    </div>
    
    <!-- VENDER -->
    <div class="shop-category" id="market-sell">
      <h3 style="margin-bottom: 15px; color: #fff; text-shadow: 2px 2px 4px rgba(0,0,0,0.5);">Selecciona un objeto de tu inventario para vender:</h3>
      <div id="marketSellInventory" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 15px; max-height: 400px; overflow-y: auto;">
        <!-- Inventario para vender se cargar√° aqu√≠ -->
      </div>
    </div>
    
    <!-- MIS OFERTAS -->
    <div class="shop-category" id="market-my">
      <div id="marketMyOffers" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 15px; max-height: 500px; overflow-y: auto;">
        <!-- Mis ofertas se cargar√°n aqu√≠ -->
      </div>
    </div>
  </div>
</div>
<div class="modal" id="globalShopModal">
  <div class="modal-content fullscreen">
    <button class="modal-close-top-left" id="closeGlobalShop">‚úï</button>
    <h2>üåê Tienda Global</h2>
    <div class="shop-tabs">
      <button class="shop-tab active" data-tab="decorations">üé® Decoraciones</button>
      <button class="shop-tab" data-tab="weapons">‚öîÔ∏è Armas</button>
      <button class="shop-tab" data-tab="defenses">üõ°Ô∏è Defensas</button>
    </div>
    
    <!-- DECORACIONES -->
    <div class="shop-category active" id="shop-decorations">
      <div class="shop-item" id="statueItem">
        <div class="shop-item-info">
          <div class="shop-item-name">üóø Estatua Moai</div>
          <div class="shop-item-desc">Estatua decorativa √∫nica para tu aldea</div>
          <div class="shop-item-desc">Stock: <span id="statueStock">10</span></div>
          <div class="shop-item-cost">üí∞ 500 Oro</div>
        </div>
        <button id="buyStatueBtn">Comprar</button>
      </div>
      <div class="shop-item" id="flowerItem">
        <div class="shop-item-info">
          <div class="shop-item-name">üå∏ Flor Decorativa</div>
          <div class="shop-item-desc">Hermosa flor para decorar tu aldea</div>
          <div class="shop-item-desc">Stock: <span id="flowerStock">15</span></div>
          <div class="shop-item-cost">üí∞ 200 Oro</div>
        </div>
        <button id="buyFlowerBtn">Comprar</button>
      </div>
    </div>
    
    <!-- ARMAS -->
    <div class="shop-category" id="shop-weapons">
      <div class="shop-item" id="rocketAmmoItem">
        <div class="shop-item-info">
          <div class="shop-item-name">üöÄ Cohetes</div>
          <div class="shop-item-desc">Municiones para el Lanza Cohetes (da√±o 7x7)</div>
          <div class="shop-item-desc">Stock: <span id="rocketAmmoStock">10</span></div>
          <div class="shop-item-cost">üí∞ 3000 Oro</div>
        </div>
        <button id="buyRocketAmmoBtn">Comprar</button>
      </div>
      <div class="shop-item" id="superRocketAmmoItem">
        <div class="shop-item-info">
          <div class="shop-item-name">üí• Super Cohetes</div>
          <div class="shop-item-desc">Municiones para el Super Lanzador (da√±o 15x15) ‚ö†Ô∏è DEVASTADOR</div>
          <div class="shop-item-desc">Stock: <span id="superRocketAmmoStock">5</span></div>
          <div class="shop-item-cost">üí∞ 8000 Oro</div>
        </div>
        <button id="buySuperRocketAmmoBtn">Comprar</button>
      </div>
      <div class="shop-item" id="bomberPlaneItem">
        <div class="shop-item-info">
          <div class="shop-item-name">‚úàÔ∏è Avi√≥n Bombardero</div>
          <div class="shop-item-desc">Bombardea en l√≠nea recta, da√±o 3x3 por bomba</div>
          <div class="shop-item-desc">Stock: <span id="bomberPlaneStock">8</span></div>
          <div class="shop-item-cost">üí∞ 2500 Oro</div>
        </div>
        <button id="buyBomberPlaneBtn">Comprar</button>
      </div>
    </div>
    
    <!-- DEFENSAS -->
    <div class="shop-category" id="shop-defenses">
      <div class="shop-item" id="superRocketLauncherItem">
        <div class="shop-item-info">
          <div class="shop-item-name">üí• Super Lanzador</div>
          <div class="shop-item-desc">Lanzador de Super Cohetes (m√°x. 1 por aldea) ‚ö†Ô∏è DA√ëA TU ALDEA AL LANZAR</div>
          <div class="shop-item-desc">Stock: <span id="superRocketLauncherStock">3</span></div>
          <div class="shop-item-cost">üí∞ 10000 Oro</div>
        </div>
        <button id="buySuperRocketLauncherGlobalBtn">Comprar</button>
      </div>
      <div class="shop-item" id="deflectorTowerItem">
        <div class="shop-item-info">
          <div class="shop-item-name">üõ°Ô∏è Torre Desviadora</div>
          <div class="shop-item-desc">Desv√≠a cohetes enemigos al mar (rango: 5 celdas)</div>
          <div class="shop-item-desc">Stock: <span id="deflectorTowerStock">5</span></div>
          <div class="shop-item-cost">üí∞ 1500 Oro</div>
        </div>
        <button id="buyDeflectorTowerBtn">Comprar</button>
      </div>
    </div>
  </div>
</div>
<div class="modal" id="attackModal">
  <div class="modal-content small">
    <h2>Elige Ataque</h2>
    <button class="attack-option" data-attack="rob">Robar Oro (100 oro, roba hasta 50)</button>
    <button class="attack-option" data-attack="bomb">Lanzar Bomba (100 oro, da√±a √°rea 3x3)</button>
    <button class="attack-option" data-attack="rocket">Lanzar Cohete (Requiere munici√≥n, da√±a √°rea 7x7)</button>
    <button class="attack-option" data-attack="superRocket">üí• SUPER COHETE (Requiere munici√≥n, da√±a √°rea 15x15) ‚ö†Ô∏è DA√ëA TU ALDEA</button>
    <button class="attack-option" data-attack="bomber">‚úàÔ∏è Avi√≥n Bombardero (Requiere avi√≥n, bombardeo en l√≠nea)</button>
    <button class="modal-close" id="closeAttack">Cancelar</button>
  </div>
</div>
<div class="modal" id="topPlayersModal">
  <div class="modal-content">
    <h2>üèÜ Top Jugadores</h2>
    <div id="topPlayersList"></div>
    <button class="modal-close" id="closeTopPlayers">Cerrar</button>
  </div>
</div>
<div class="modal" id="achievementsModal">
  <div class="modal-content large">
    <h2>üèÜ Logros</h2>
    <div id="achievementsList"></div>
    <button class="modal-close" id="closeAchievements">Cerrar</button>
  </div>
</div>
<div class="modal" id="tutorialModal">
  <div class="modal-content large">
    <h2>üéì Tutorial</h2>
    <div id="tutorialSteps">
      <div class="tutorial-step active" data-step="1">
        <div class="tutorial-icon">üëã</div>
        <div class="tutorial-text">¬°Bienvenido a Aldeas!<br><br>Este es un juego de construcci√≥n y estrategia donde podr√°s crear tu propia aldea y competir con otros jugadores.</div>
      </div>
      <div class="tutorial-step" data-step="2">
        <div class="tutorial-icon">üè∞</div>
        <div class="tutorial-text">Para empezar, haz click en cualquier <strong>celda verde</strong> del mapa para construir tu aldea.<br><br>Solo puedes construir una aldea, ¬°as√≠ que elige bien la ubicaci√≥n!</div>
      </div>
      <div class="tutorial-step" data-step="3">
        <div class="tutorial-icon">üèùÔ∏è</div>
        <div class="tutorial-text">Una vez construida, haz click en tu castillo para entrar a tu isla.<br><br>Aqu√≠ podr√°s construir edificios y mejorar tu aldea.</div>
      </div>
      <div class="tutorial-step" data-step="4">
        <div class="tutorial-icon">üí∞</div>
        <div class="tutorial-text">En la tienda puedes comprar <strong>Minas de Oro</strong> que generan oro cada 5 segundos.<br><br>El oro te permite comprar m√°s edificios y mejorar tu aldea.</div>
      </div>
      <div class="tutorial-step" data-step="5">
        <div class="tutorial-icon">üìà</div>
        <div class="tutorial-text">Gana <strong>XP</strong> construyendo edificios y generando recursos.<br><br>Sube de nivel para desbloquear m√°s contenido y aparecer en el ranking.</div>
      </div>
      <div class="tutorial-step" data-step="6">
        <div class="tutorial-icon">üéÆ</div>
        <div class="tutorial-text">¬°Eso es todo!<br><br>Explora el mapa, visita otras aldeas y convi√©rtete en el mejor jugador.<br><br><strong>¬°Buena suerte!</strong></div>
      </div>
    </div>
    <div class="tutorial-buttons">
      <button class="tutorial-button secondary" id="tutorialPrev">‚Üê Anterior</button>
      <button class="tutorial-button primary" id="tutorialNext">Siguiente ‚Üí</button>
    </div>
    <div class="tutorial-progress">Paso <span id="tutorialCurrentStep">1</span> de <span id="tutorialTotalSteps">6</span></div>
  </div>
</div>
<div class="modal" id="villageOptionsModal">
  <div class="modal-content small">
    <h2>üè∞ <span id="villageOptionsOwner"></span></h2>
    <p style="color: white; text-align: center; margin-bottom: 20px;">Esta aldea est√° bajo ataque</p>
    <button class="attack-option" id="viewVillageBtn">üèùÔ∏è Ver Aldea</button>
    <button class="attack-option" id="spectateBtn">üëÅÔ∏è Espectear Ataque (Tiempo Real)</button>
    <button class="modal-close" id="closeVillageOptions">Cancelar</button>
  </div>
</div>
<div class="modal" id="loginModal">
  <div class="modal-content small">
    <h2>üè∞ Aldeas</h2>
    <div class="login-tabs">
      <button class="tab-button active" id="loginTab">Iniciar Sesi√≥n</button>
      <button class="tab-button" id="registerTab">Registrarse</button>
    </div>
    <div id="loginForm" class="login-form active">
      <div class="form-group">
        <label>Nombre de Usuario</label>
        <input type="text" id="loginUsername" placeholder="Ingresa tu nombre">
      </div>
      <div class="form-group">
        <label>Contrase√±a</label>
        <input type="password" id="loginPassword" placeholder="Ingresa tu contrase√±a">
      </div>
      <button class="login-button" id="loginBtn">Entrar</button>
      <div class="error-message" id="loginError"></div>
    </div>
    <div id="registerForm" class="login-form">
      <div class="form-group">
        <label>Nombre de Usuario</label>
        <input type="text" id="registerUsername" placeholder="Elige un nombre">
      </div>
      <div class="form-group">
        <label>Contrase√±a</label>
        <input type="password" id="registerPassword" placeholder="Elige una contrase√±a">
      </div>
      <div class="form-group">
        <label>Confirmar Contrase√±a</label>
        <input type="password" id="registerPasswordConfirm" placeholder="Confirma tu contrase√±a">
      </div>
      <button class="login-button" id="registerBtn">Crear Cuenta</button>
      <div class="error-message" id="registerError"></div>
    </div>
  </div>
</div>
<div id="fade"></div>
<div id="loading">Cargando...</div>
<audio id="shopMusic" loop>
  <source src="recursos/Untitled.mp3" type="audio/mpeg">
</audio>
<audio id="rocketSound">
  <source src="recursos/Rocket launchersoundeffect.mp3" type="audio/mpeg">
</audio>
<audio id="explosionSound">
  <source src="recursos/explosi√≥n.mp3" type="audio/mpeg">
</audio>
<script type="module">
import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
import { getDatabase, ref, set, onValue, get, runTransaction } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js';
const app = initializeApp({
  apiKey: "AIzaSyClTAw_XLfH3UcCKTisTREZchz41tTxL7g",
  authDomain: "projectmap-382dd.firebaseapp.com",
  databaseURL: "https://projectmap-382dd-default-rtdb.firebaseio.com",
  projectId: "projectmap-382dd",
  storageBucket: "projectmap-382dd.firebasestorage.app",
  messagingSenderId: "1016267509437",
  appId: "1:1016267509437:web:fa243dd82b151383ccb1d4",
  measurementId: "G-4ECYZ37F17"
});
const db = getDatabase(app);
// State
const state = {
  user: null,
  hasBuilt: false,
  currentVillage: { owner: null, id: null },
  resources: { gold: 0 },
  buildings: { mines: [], rocketLaunchers: [], superRocketLaunchers: [], statues: [], flowers: [], deflectorTowers: [], aaTurrets: [], damaged: [] },
  level: { level: 1, xp: 0, needed: 100 },
  inventory: [],
  placing: null,
  attacking: false,
  achievements: {},
  tutorial: { step: 1 },
  nightMode: false,
  textureMode: false,
  grids: { main: true, island: true },
  view: { main: { x: 0, y: 0, scale: 1 }, island: { x: 0, y: 0, scale: 1 } },
  drag: { active: false, moved: false, startX: 0, startY: 0 },
  map: [],
  cells: {},
  intervals: { gold: null, particles: {} },
  skipCentering: false,
  shovelLevel: 1, // Nivel de la pala (x1 a x5)
  isProcessingClick: false, // Prevenir clics m√∫ltiples
  selectedVillage: null, // Aldea seleccionada para espectear
  spectating: false, // Modo espectador activo
  spectateListener: null, // Listener de Firebase para espectador
  spectateAttackListener: null, // Listener de ataques para espectador
  bomberActive: false, // Indica si hay un bombardero activo
  dragLocked: false, // Bloquear movimiento del mapa durante ataques
  moving: null // Info de estructura que se est√° moviendo
};
const ACHIEVEMENTS = {
  firstVillage: { id: 'firstVillage', name: 'Primer Constructor', desc: 'Construye tu primera aldea', icon: 'üè∞', reward: '+50 XP' },
  firstMine: { id: 'firstMine', name: 'Minero Novato', desc: 'Construye tu primera mina de oro', icon: '‚õèÔ∏è', reward: '+25 XP' },
  level5: { id: 'level5', name: 'Ascenso', desc: 'Alcanza el nivel 5', icon: '‚≠ê', reward: '+100 Oro' },
  level10: { id: 'level10', name: 'Veterano', desc: 'Alcanza el nivel 10', icon: 'üåü', reward: '+200 Oro' },
  rich: { id: 'rich', name: 'Rico', desc: 'Acumula 500 de oro', icon: 'üí∞', reward: '+50 XP' },
  millionaire: { id: 'millionaire', name: 'Millonario', desc: 'Acumula 1000 de oro', icon: 'üíé', reward: '+100 XP' },
  maxMines: { id: 'maxMines', name: 'Imperio Minero', desc: 'Construye el m√°ximo de minas (2)', icon: '‚öíÔ∏è', reward: '+50 XP' },
  explorer: { id: 'explorer', name: 'Explorador', desc: 'Visita la aldea de otro jugador', icon: 'üó∫Ô∏è', reward: '+25 XP' },
  rocketLauncher: { id: 'rocketLauncher', name: 'Pionero Espacial', desc: 'Construye el lanza cohetes', icon: 'üöÄ', reward: '+500 XP' },
  deflectorTower: { id: 'deflectorTower', name: 'Escudo Defensivo', desc: 'Construye la Torre Desviadora', icon: 'üõ°Ô∏è', reward: '+300 XP' },
  spectator: { id: 'spectator', name: 'Observador', desc: 'Espectea el ataque de un jugador', icon: 'üëÅÔ∏è', reward: '+50 XP' },
  planeDestroyer: { id: 'planeDestroyer', name: 'As del Cielo', desc: 'Derriba un avi√≥n bombardero enemigo', icon: 'üóº', reward: '+200 XP' }
};
// DOM Elements
const $ = id => document.getElementById(id);
const modal = name => $(name + 'Modal');
// Utility Functions
const show = el => el.style.display = el.classList.contains('modal') ? 'flex' : 'block';
const hide = el => el.style.display = 'none';
const loading = show => $(show ? 'loading' : 'loading').style.display = show ? 'block' : 'none';
// Initialize Map
function initMap() {
  const grid = $('mainGrid');
  for (let r = 0; r < 50; r++) {
    state.map[r] = [];
    for (let c = 0; c < 50; c++) {
      let terrain = r === 0 || r === 49 || c === 0 || c === 49 ? 'wall' :
                    r % 10 === 0 || c % 10 === 0 ? 'road' :
                    Math.random() < 0.05 ? 'mountain' : 'grass';
     
      state.map[r][c] = { terrain, building: null, owner: null };
     
      const cell = document.createElement('div');
      cell.className = `cell ${terrain}`;
      cell.dataset.row = r;
      cell.dataset.col = c;
      cell.onclick = () => handleMainClick(cell);
     
      state.cells[`${r}-${c}`] = cell;
      grid.appendChild(cell);
    }
  }
}
// Funci√≥n para detectar y eliminar aldeas duplicadas
async function removeDuplicateVillages() {
  const villagesSnap = await get(ref(db, 'villages'));
  if (!villagesSnap.exists()) return;
  
  const villages = villagesSnap.val();
  const ownerMap = {}; // Mapa de due√±o -> [aldeas]
  
  // Agrupar aldeas por due√±o
  Object.entries(villages).forEach(([key, village]) => {
    if (!ownerMap[village.owner]) {
      ownerMap[village.owner] = [];
    }
    ownerMap[village.owner].push({ id: key, ...village });
  });
  
  // Eliminar duplicados (dejar solo la primera aldea de cada jugador)
  for (const [owner, villageList] of Object.entries(ownerMap)) {
    if (villageList.length > 1) {
      console.log(`‚ö†Ô∏è Jugador ${owner} tiene ${villageList.length} aldeas. Eliminando duplicados...`);
      
      // Ordenar por ID (la primera creada tiene el ID m√°s antiguo)
      villageList.sort((a, b) => a.id.localeCompare(b.id));
      
      // Eliminar todas excepto la primera
      for (let i = 1; i < villageList.length; i++) {
        const duplicateId = villageList[i].id;
        console.log(`üóëÔ∏è Eliminando aldea duplicada: ${duplicateId} de ${owner}`);
        await set(ref(db, `villages/${duplicateId}`), null);
        
        // Tambi√©n eliminar los datos del usuario asociados a esta aldea duplicada
        // (mantener solo los datos de la primera aldea)
      }
    }
  }
}

// Firebase Listeners
function setupListeners() {
  onValue(ref(db, 'villages'), snap => {
    if (!snap.exists()) return;
    
    // Verificar duplicados cada vez que se cargan las aldeas
    removeDuplicateVillages();
    
    Object.entries(snap.val()).forEach(([key, v]) => {
      const cell = state.cells[`${v.row}-${v.col}`];
      if (!cell) return;
     
      state.map[v.row][v.col] = { ...state.map[v.row][v.col], building: 'house', owner: v.owner };
      cell.classList.add('building');
      
      // Verificar salud del castillo
      const castleHealth = v.castleHealth !== undefined ? v.castleHealth : 3;
      
      if (castleHealth <= 0) {
        // Castillo destruido
        cell.textContent = 'üï≥Ô∏è';
        cell.classList.remove('my-castle', 'enemy-castle');
        cell.classList.add('destroyed-castle');
        
        // Iniciar part√≠culas de humo continuas en el castillo destruido
        const smokeId = `destroyed_${key}`;
        if (!state.intervals.particles[smokeId]) {
          state.intervals.particles[smokeId] = setInterval(() => {
            const smoke = document.createElement('div');
            smoke.style.position = 'absolute';
            smoke.style.left = (Math.random() * cell.offsetWidth) + 'px';
            smoke.style.bottom = '0px';
            smoke.style.width = (15 + Math.random() * 20) + 'px';
            smoke.style.height = smoke.style.width;
            smoke.style.borderRadius = '50%';
            smoke.style.background = `rgba(${60 + Math.random() * 40}, ${60 + Math.random() * 40}, ${60 + Math.random() * 40}, ${0.6 + Math.random() * 0.3})`;
            smoke.style.pointerEvents = 'none';
            smoke.style.zIndex = '5';
            cell.appendChild(smoke);
            
            setTimeout(() => {
              smoke.style.transition = 'all 2.5s ease-out';
              smoke.style.transform = `translateY(-${cell.offsetHeight + 30}px) scale(1.8)`;
              smoke.style.opacity = '0';
            }, 50);
            
            setTimeout(() => smoke.remove(), 2600);
          }, 200);
        }
      } else {
        // Castillo normal - detener part√≠culas de fuego si exist√≠an
        const fireId = `destroyed_${key}`;
        if (state.intervals.particles[fireId]) {
          clearInterval(state.intervals.particles[fireId]);
          delete state.intervals.particles[fireId];
        }
        
        cell.textContent = 'üè∞';
        
        // Agregar clase seg√∫n si es mi aldea o no
        if (v.owner === state.user) {
          cell.classList.add('my-castle');
        } else {
          cell.classList.add('enemy-castle');
        }
      }
     
      const label = document.createElement('div');
      label.className = 'owner-name';
      label.textContent = castleHealth <= 0 ? `${v.owner} (Destruido)` : v.owner;
      cell.appendChild(label);
     
      if (v.underAttack) startParticles(key, cell);
      else stopParticles(key);
    });
    loading(false);
  });
}
function startParticles(id, cell) {
  if (state.intervals.particles[id]) return;
  state.intervals.particles[id] = setInterval(() => {
    const p = document.createElement('div');
    p.className = 'particula';
    p.style.left = Math.random() * cell.offsetWidth + 'px';
    p.style.top = Math.random() * cell.offsetHeight + 'px';
    const red = 200 + Math.random() * 55;
    const orange = Math.random() * 100;
    p.style.background = `rgb(${red}, ${orange}, 0)`;
    cell.appendChild(p);
    p.onanimationend = () => p.remove();
  }, 80);
}
function stopParticles(id) {
  if (state.intervals.particles[id]) {
    clearInterval(state.intervals.particles[id]);
    delete state.intervals.particles[id];
  }
}
// Main Map Interactions
async function handleMainClick(cell) {
  if (state.drag.moved) return;
  
  // CR√çTICO: Prevenir clics m√∫ltiples mientras se procesa
  if (state.isProcessingClick) {
    return;
  }
  
  const r = +cell.dataset.row, c = +cell.dataset.col;
 
  if (state.map[r][c].building === 'house') {
    const owner = state.map[r][c].owner;
    const villageId = `${r}-${c}`;
    
    // Verificar si la aldea est√° bajo ataque
    const villageSnap = await get(ref(db, `villages/${villageId}`));
    if (villageSnap.exists() && villageSnap.val().underAttack) {
      // Mostrar modal con opciones
      $('villageOptionsOwner').textContent = owner;
      show(modal('villageOptions'));
      
      // Guardar datos para los botones
      state.selectedVillage = { owner, id: villageId, row: r, col: c };
      return;
    }
    
    openIsland(owner);
    return;
  }
 
  if (!state.user) {
    alert('Debes iniciar sesi√≥n para construir tu aldea');
    return;
  }
 
  if (state.hasBuilt || state.map[r][c].terrain !== 'grass' || state.map[r][c].building) {
    if (state.hasBuilt) alert('Ya has colocado tu aldea. Solo puedes construir una aldea.');
    return;
  }
 
  // Marcar como procesando
  state.isProcessingClick = true;
  loading(true);
  
  try {
    const id = `${r}-${c}`;
    
    // CR√çTICO: Verificar si ya existe una aldea en esta posici√≥n
    const existingVillageSnap = await get(ref(db, `villages/${id}`));
    if (existingVillageSnap.exists()) {
      const existingVillage = existingVillageSnap.val();
      loading(false);
      state.isProcessingClick = false;
      alert(`Ya existe una aldea en esta posici√≥n (${existingVillage.owner}). Por favor, elige otra ubicaci√≥n.`);
      // Actualizar el mapa local para reflejar la aldea existente
      state.map[r][c].building = 'house';
      state.map[r][c].owner = existingVillage.owner;
      renderMap();
      return;
    }
    
    // Verificar si el usuario ya tiene una aldea
    const allVillagesSnap = await get(ref(db, 'villages'));
    if (allVillagesSnap.exists()) {
      const villages = allVillagesSnap.val();
      for (const villageId in villages) {
        if (villages[villageId].owner === state.user) {
          loading(false);
          state.isProcessingClick = false;
          alert('Ya tienes una aldea construida. Solo puedes tener una aldea.');
          state.hasBuilt = true;
          return;
        }
      }
    }
    
    // Crear la aldea con salud del castillo
    await set(ref(db, `villages/${id}`), { 
      row: r, 
      col: c, 
      owner: state.user, 
      timestamp: Date.now(),
      castleHealth: 500,  // El castillo tiene 500 puntos de vida
      castleMaxHealth: 500
    });
    state.hasBuilt = true;
    await unlockAchievement('firstVillage');
    loading(false);
    state.isProcessingClick = false;
  } catch (error) {
    console.error('Error al crear aldea:', error);
    alert('Error al crear la aldea. Por favor, intenta de nuevo.');
    loading(false);
    state.isProcessingClick = false;
  }
}
// Island Functions
async function openIsland(owner) {
  state.currentVillage = { owner, id: null, castleHealth: 500, castleMaxHealth: 500 };
  $('ownerName').textContent = owner;
 
  if (owner !== state.user && state.user) unlockAchievement('explorer');
  
  // Cargar salud del castillo desde Firebase
  const villagesSnap = await get(ref(db, 'villages'));
  if (villagesSnap.exists()) {
    const villages = villagesSnap.val();
    for (const villageId in villages) {
      if (villages[villageId].owner === owner) {
        state.currentVillage.id = villageId;
        state.currentVillage.castleHealth = villages[villageId].castleHealth !== undefined ? villages[villageId].castleHealth : 500;
        state.currentVillage.castleMaxHealth = villages[villageId].castleMaxHealth || 500;
        break;
      }
    }
  }
 
  await Promise.all([loadBuildings(owner), loadResources(owner), loadLevel(owner)]);
 
  if (owner === state.user && state.buildings.mines.length > 0) startGoldGen();
 
  renderIsland();
  if (!state.skipCentering) {
    setTimeout(() => {
      const viewport = $('islandViewport');
      const grid = $('islandGrid');
      state.view.island.x = (viewport.clientWidth - grid.offsetWidth * state.view.island.scale) / 2;
      state.view.island.y = (viewport.clientHeight - grid.offsetHeight * state.view.island.scale) / 2;
      updateTransform('island');
    }, 50);
  }
  transition(true);
 
  $('shopButton').style.display = owner === state.user ? 'block' : 'none';
  $('inventoryButton').style.display = owner === state.user ? 'block' : 'none';
  $('marketButton').style.display = owner === state.user ? 'block' : 'none';
  $('attackButton').style.display = owner !== state.user && state.user ? 'block' : 'none';
}
async function startSpectating(village) {
  state.spectating = true;
  state.currentVillage = { owner: village.owner, id: village.id };
  $('ownerName').textContent = village.owner + ' (ESPECTANDO)';
  
  // Desbloquear logro de espectador
  await unlockAchievement('spectator');
  
  // Cargar datos iniciales
  await Promise.all([loadBuildings(village.owner), loadResources(village.owner), loadLevel(village.owner)]);
  
  renderIsland();
  transition(true);
  
  // Ocultar botones de acci√≥n
  $('shopButton').style.display = 'none';
  $('inventoryButton').style.display = 'none';
  $('marketButton').style.display = 'none';
  $('attackButton').style.display = 'none';
  $('backButton').textContent = '‚Üê Salir de Espectador';
  
  // Escuchar eventos de ataque en tiempo real
  state.spectateAttackListener = onValue(ref(db, `villages/${village.id}/currentAttack`), async (snap) => {
    if (snap.exists() && state.spectating) {
      const attackData = snap.val();
      
      if (attackData && attackData.active) {
        // Reproducir animaci√≥n de ataque
        await playSpectatorAttack(attackData);
      }
    }
  });
  
  // Escuchar cambios en edificios (m√°s r√°pido con menos delay)
  state.spectateListener = onValue(ref(db, `users/${village.owner}/buildings`), async (snap) => {
    if (snap.exists() && state.spectating) {
      const newBuildings = snap.val();
      
      state.buildings = {
        mines: newBuildings.goldMines || newBuildings.mines || [],
        rocketLaunchers: newBuildings.rocketLaunchers || [],
        superRocketLaunchers: newBuildings.superRocketLaunchers || [],
        deflectorTowers: newBuildings.deflectorTowers || [],
        statues: newBuildings.statues || [],
        flowers: newBuildings.flowers || [],
        damaged: newBuildings.damaged || []
      };
      
      renderIsland();
    }
  });
  
  // Modificar el bot√≥n de regresar para salir del modo espectador
  $('backButton').onclick = () => {
    if (state.spectating) {
      stopSpectating();
      $('backButton').textContent = '‚Üê Volver al Mapa';
      
      // Volver al mapa principal
      document.querySelector('.map-view').style.opacity = 1;
      document.querySelector('.island-view').style.opacity = 0;
      document.querySelector('.island-view').style.pointerEvents = 'none';
      document.querySelector('.map-view').style.pointerEvents = 'auto';
      $('fade').style.opacity = 0;
    }
  };
}
function stopSpectating() {
  state.spectating = false;
  if (state.spectateListener) {
    state.spectateListener();
    state.spectateListener = null;
  }
  if (state.spectateAttackListener) {
    state.spectateAttackListener();
    state.spectateAttackListener = null;
  }
}
async function playSpectatorAttack(attackData) {
  if (!attackData.actions || attackData.actions.length === 0) return;
  
  // Reproducir cada acci√≥n con el timing correcto
  for (const action of attackData.actions) {
    // Esperar el tiempo especificado
    await new Promise(resolve => setTimeout(resolve, action.delay || 0));
    
    if (action.type === 'transition_attacker') {
      // Transici√≥n a la aldea del atacante
      $('fade').style.opacity = 1;
      await new Promise(resolve => setTimeout(resolve, 400));
      
      // Cargar aldea del atacante
      state.skipCentering = true;
      await openIsland(action.attacker);
      
      setTimeout(() => $('fade').style.opacity = 0, 100);
      
    } else if (action.type === 'rocket_launch') {
      // Mostrar cohete despegando
      const launcherCell = $('islandGrid').querySelector(`[data-row="${action.launcherRow}"][data-col="${action.launcherCol}"]`);
      if (!launcherCell) continue;
      
      const launcherRect = launcherCell.getBoundingClientRect();
      const rocket = document.createElement('div');
      rocket.style.position = 'fixed';
      rocket.style.fontSize = '40px';
      rocket.style.left = launcherRect.left + launcherRect.width / 2 - 20 + 'px';
      rocket.style.top = launcherRect.top + launcherRect.height / 2 - 20 + 'px';
      rocket.style.zIndex = '10001';
      rocket.textContent = 'üöÄ';
      rocket.style.filter = 'drop-shadow(0 0 10px rgba(255, 100, 0, 0.8))';
      document.body.appendChild(rocket);
      
      // Variables para la animaci√≥n
      const rocketStartTime = Date.now();
      const rocketDuration = 3500;
      const rocketStartY = parseFloat(rocket.style.top);
      const rocketStartX = parseFloat(rocket.style.left);
      const rocketEndY = rocketStartY - 1200;
      
      // Part√≠culas de humo
      const smokeInterval = setInterval(() => {
        const elapsed = Date.now() - rocketStartTime;
        const progress = Math.min(elapsed / rocketDuration, 1);
        const easeProgress = progress * progress;
        const currentRocketY = rocketStartY - (easeProgress * (rocketStartY - rocketEndY));
        
        for (let i = 0; i < 3; i++) {
          const smoke = document.createElement('div');
          smoke.style.position = 'fixed';
          smoke.style.left = (rocketStartX + 20 + (Math.random() - 0.5) * 15) + 'px';
          smoke.style.top = (currentRocketY + 35) + 'px';
          smoke.style.width = (8 + Math.random() * 12) + 'px';
          smoke.style.height = (8 + Math.random() * 12) + 'px';
          smoke.style.borderRadius = '50%';
          const opacity = 0.6 + Math.random() * 0.3;
          const gray = 180 + Math.random() * 75;
          smoke.style.background = `rgba(${gray}, ${gray}, ${gray}, ${opacity})`;
          smoke.style.boxShadow = `0 0 8px rgba(255, 255, 255, 0.5)`;
          smoke.style.zIndex = '10000';
          smoke.style.pointerEvents = 'none';
          document.body.appendChild(smoke);
          
          const spreadX = (Math.random() - 0.5) * 50;
          const spreadY = Math.random() * 40 + 30;
          const duration = 1000 + Math.random() * 500;
          smoke.style.transition = `all ${duration}ms ease-out`;
          
          setTimeout(() => {
            smoke.style.transform = `translate(${spreadX}px, ${spreadY}px) scale(2.5)`;
            smoke.style.opacity = '0';
          }, 50);
          
          setTimeout(() => smoke.remove(), duration + 100);
        }
      }, 70);
      
      // Animar cohete
      const animateRocket = () => {
        const elapsed = Date.now() - rocketStartTime;
        const progress = Math.min(elapsed / rocketDuration, 1);
        const easeProgress = progress * progress;
        const currentY = rocketStartY - (easeProgress * (rocketStartY - rocketEndY));
        rocket.style.top = currentY + 'px';
        
        if (progress > 0.7) {
          rocket.style.opacity = (1 - (progress - 0.7) / 0.3).toString();
        }
        
        if (progress < 1) {
          requestAnimationFrame(animateRocket);
        }
      };
      
      requestAnimationFrame(animateRocket);
      await new Promise(resolve => setTimeout(resolve, rocketDuration));
      clearInterval(smokeInterval);
      rocket.remove();
      
    } else if (action.type === 'transition_target') {
      // Transici√≥n a la aldea objetivo
      $('fade').style.opacity = 1;
      await new Promise(resolve => setTimeout(resolve, 400));
      
      state.skipCentering = true;
      await openIsland(action.target);
      
      setTimeout(() => $('fade').style.opacity = 0, 100);
      
    } else if (action.type === 'rocket_fall') {
      // Cohete cayendo
      const targetCell = $('islandGrid').querySelector(`[data-row="${action.targetRow}"][data-col="${action.targetCol}"]`);
      if (!targetCell) continue;
      
      const targetRect = targetCell.getBoundingClientRect();
      const targetCenterX = targetRect.left + targetRect.width / 2;
      const targetCenterY = targetRect.top + targetRect.height / 2;
      
      const fallingRocket = document.createElement('div');
      fallingRocket.style.position = 'fixed';
      fallingRocket.style.fontSize = '40px';
      fallingRocket.style.left = targetCenterX - 20 + 'px';
      fallingRocket.style.top = '-100px';
      fallingRocket.style.zIndex = '10001';
      fallingRocket.textContent = 'üöÄ';
      fallingRocket.style.transform = 'rotate(180deg)';
      fallingRocket.style.transition = 'top 1.5s ease-in';
      fallingRocket.style.filter = 'drop-shadow(0 0 15px rgba(255, 50, 0, 1))';
      document.body.appendChild(fallingRocket);
      
      setTimeout(() => {
        fallingRocket.style.top = targetCenterY - 20 + 'px';
      }, 100);
      
      await new Promise(resolve => setTimeout(resolve, 1600));
      fallingRocket.remove();
      
    } else if (action.type === 'explosion') {
      // Explosi√≥n
      const targetCell = $('islandGrid').querySelector(`[data-row="${action.targetRow}"][data-col="${action.targetCol}"]`);
      if (!targetCell) continue;
      
      const targetRect = targetCell.getBoundingClientRect();
      createExplosion(targetRect.left + targetRect.width / 2, targetRect.top + targetRect.height / 2);
      
      const viewport = $('islandViewport');
      viewport.classList.add('shake');
      setTimeout(() => viewport.classList.remove('shake'), 500);
    }
  }
}
function renderIsland() {
  const grid = $('islandGrid');
  grid.innerHTML = '';
 
  for (let r = 0; r < 20; r++) {
    for (let c = 0; c < 20; c++) {
      const cell = document.createElement('div');
      cell.className = 'cell grass';
      cell.dataset.row = r;
      cell.dataset.col = c;
      cell.onclick = () => handleIslandClick(cell);
     
      if (r === 10 && c === 10) {
        cell.classList.add('center');
        cell.classList.remove('grass');
        
        // Verificar salud del castillo
        const castleHealth = state.currentVillage.castleHealth !== undefined ? state.currentVillage.castleHealth : 3;
        
        if (castleHealth <= 0) {
          // Castillo destruido
          cell.textContent = 'üï≥Ô∏è';
          cell.classList.add('destroyed-castle');
          
          // Iniciar part√≠culas de humo continuas en el castillo destruido
          const smokeId = 'destroyed_castle_island';
          if (!state.intervals.particles[smokeId]) {
            state.intervals.particles[smokeId] = setInterval(() => {
              const smoke = document.createElement('div');
              smoke.style.position = 'absolute';
              smoke.style.left = (Math.random() * cell.offsetWidth) + 'px';
              smoke.style.bottom = '0px';
              smoke.style.width = (15 + Math.random() * 20) + 'px';
              smoke.style.height = smoke.style.width;
              smoke.style.borderRadius = '50%';
              smoke.style.background = `rgba(${60 + Math.random() * 40}, ${60 + Math.random() * 40}, ${60 + Math.random() * 40}, ${0.6 + Math.random() * 0.3})`;
              smoke.style.pointerEvents = 'none';
              smoke.style.zIndex = '5';
              cell.appendChild(smoke);
              
              setTimeout(() => {
                smoke.style.transition = 'all 2.5s ease-out';
                smoke.style.transform = `translateY(-${cell.offsetHeight + 30}px) scale(1.8)`;
                smoke.style.opacity = '0';
              }, 50);
              
              setTimeout(() => smoke.remove(), 2600);
            }, 200);
          }
        } else {
          // Castillo normal - detener part√≠culas de fuego si exist√≠an
          const fireId = 'destroyed_castle_island';
          if (state.intervals.particles[fireId]) {
            clearInterval(state.intervals.particles[fireId]);
            delete state.intervals.particles[fireId];
          }
          
          cell.textContent = 'üè∞';
          
          // Calcular salud del castillo
          const castleHealth = state.currentVillage.castleHealth !== undefined ? state.currentVillage.castleHealth : 500;
          const castleMaxHealth = state.currentVillage.castleMaxHealth || 500;
          const healthPercent = (castleHealth / castleMaxHealth) * 100;
          const isCastleDamaged = castleHealth < castleMaxHealth;
          
          // Agregar clase seg√∫n si es mi aldea o no
          if (state.currentVillage.owner === state.user) {
            cell.classList.add('my-castle');
          } else {
            cell.classList.add('enemy-castle');
          }
          
          // Agregar clase de da√±o si tiene menos del 50% HP
          if (healthPercent <= 50 && healthPercent > 0) {
            cell.classList.add('castle-damaged');
          }
          
          if (isCastleDamaged) {
            const healthBarContainer = document.createElement('div');
            healthBarContainer.className = 'health-bar-container';
            healthBarContainer.id = 'castle-health-bar-container';
            
            const healthBar = document.createElement('div');
            healthBar.className = 'health-bar';
            healthBar.id = 'castle-health-bar';
            
            const healthText = document.createElement('div');
            healthText.className = 'health-text';
            healthText.id = 'castle-health-text';
            
            healthBarContainer.appendChild(healthBar);
            cell.appendChild(healthBarContainer);
            cell.appendChild(healthText);
            
            // Actualizar barra de vida
            updateCastleHealthBar();
          }
        }
      }
     
      grid.appendChild(cell);
    }
  }
 
  setTimeout(() => {
    state.buildings.mines.forEach(m => {
      const c = grid.querySelector(`[data-row="${m.row}"][data-col="${m.col}"]`);
      if (c) { c.classList.add('gold-mine'); c.textContent = '‚õèÔ∏è'; }
    });
    state.buildings.rocketLaunchers.forEach(r => {
      const c = grid.querySelector(`[data-row="${r.row}"][data-col="${r.col}"]`);
      if (c) { c.classList.add('rocket-launcher'); c.textContent = 'üöÄ'; }
    });
    state.buildings.superRocketLaunchers.forEach(sr => {
      const c = grid.querySelector(`[data-row="${sr.row}"][data-col="${sr.col}"]`);
      if (c) { c.classList.add('super-rocket-launcher'); c.textContent = 'üí•'; }
    });
    state.buildings.aaTurrets.forEach(t => {
      const c = grid.querySelector(`[data-row="${t.row}"][data-col="${t.col}"]`);
      if (c) { 
        const health = t.health !== undefined ? t.health : 150;
        const maxHealth = 150;
        const isDestroyed = t.destroyed || health <= 0;
        const isDamaged = health < maxHealth;
        
        if (isDestroyed) {
          // Torre destruida
          c.classList.add('aa-turret', 'destroyed-structure');
          c.textContent = 'üî•';
          c.style.opacity = '0.6';
        } else {
          // Torre funcional
          c.classList.add('aa-turret'); 
          c.textContent = 'üóº';
          
          // Solo mostrar barra y n√∫meros si est√° da√±ada
          if (isDamaged) {
            const healthBarContainer = document.createElement('div');
            healthBarContainer.className = 'health-bar-container';
            
            const healthBar = document.createElement('div');
            healthBar.className = 'health-bar';
            const healthPercent = (health / maxHealth) * 100;
            healthBar.style.width = healthPercent + '%';
            
            if (healthPercent <= 25) {
              healthBar.classList.add('low');
            } else if (healthPercent <= 50) {
              healthBar.classList.add('medium');
            }
            
            const healthText = document.createElement('div');
            healthText.className = 'health-text';
            healthText.textContent = `${health}/${maxHealth}`;
            
            healthBarContainer.appendChild(healthBar);
            c.appendChild(healthBarContainer);
            c.appendChild(healthText);
          }
        }
      }
    });
    state.buildings.statues.forEach(s => {
      const c = grid.querySelector(`[data-row="${s.row}"][data-col="${s.col}"]`);
      if (c) { c.classList.add('statue'); c.textContent = 'üóø'; }
    });
    state.buildings.flowers.forEach(f => {
      const c = grid.querySelector(`[data-row="${f.row}"][data-col="${f.col}"]`);
      if (c) { c.classList.add('flower'); c.textContent = 'üå∏'; }
    });
    state.buildings.deflectorTowers.forEach(dt => {
      const c = grid.querySelector(`[data-row="${dt.row}"][data-col="${dt.col}"]`);
      if (c) { 
        const health = dt.health !== undefined ? dt.health : 150;
        const maxHealth = 150;
        const isDestroyed = dt.destroyed || health <= 0;
        const isDamaged = health < maxHealth;
        
        if (isDestroyed) {
          // Torre destruida
          c.classList.add('deflector-tower', 'destroyed-structure');
          c.textContent = 'üî•';
          c.style.opacity = '0.6';
        } else {
          // Torre funcional
          c.classList.add('deflector-tower'); 
          c.textContent = 'üõ°Ô∏è';
          
          // Solo mostrar barra y n√∫meros si est√° da√±ada
          if (isDamaged) {
            const healthBarContainer = document.createElement('div');
            healthBarContainer.className = 'health-bar-container';
            
            const healthBar = document.createElement('div');
            healthBar.className = 'health-bar';
            const healthPercent = (health / maxHealth) * 100;
            healthBar.style.width = healthPercent + '%';
            
            if (healthPercent <= 25) {
              healthBar.classList.add('low');
            } else if (healthPercent <= 50) {
              healthBar.classList.add('medium');
            }
            
            const healthText = document.createElement('div');
            healthText.className = 'health-text';
            healthText.textContent = `${health}/${maxHealth}`;
            
            healthBarContainer.appendChild(healthBar);
            c.appendChild(healthBarContainer);
            c.appendChild(healthText);
          }
        }
      }
    });
    state.buildings.damaged.forEach(d => {
      const c = grid.querySelector(`[data-row="${d.row}"][data-col="${d.col}"]`);
      // Solo agregar 'damaged' si la celda no tiene ninguna estructura
      if (c && !c.classList.contains('gold-mine') && !c.classList.contains('rocket-launcher') && 
          !c.classList.contains('aa-turret') && !c.classList.contains('deflector-tower') && 
          !c.classList.contains('statue') && !c.classList.contains('flower')) {
        c.classList.add('damaged');
      }
    });
  }, 100);
}
async function handleIslandClick(cell) {
  if (state.drag.moved) return;
  const r = +cell.dataset.row, c = +cell.dataset.col;
 
  // Permitir interacci√≥n con el castillo para repararlo
  if (r === 10 && c === 10) {
    if (state.currentVillage.owner === state.user) {
      showCastleRepairMenu();
    }
    return;
  }
  
  const own = state.currentVillage.owner === state.user;
  
  // Verificar si es una torre destruida
  const aaTurret = state.buildings.aaTurrets.find(aa => aa.row === r && aa.col === c);
  const deflector = state.buildings.deflectorTowers.find(dt => dt.row === r && dt.col === c);
  const isTowerDestroyed = (aaTurret && (aaTurret.destroyed || aaTurret.health <= 0)) || 
                           (deflector && (deflector.destroyed || deflector.health <= 0));
  
  // Si es una torre destruida, mostrar men√∫ de reparaci√≥n
  if (own && !state.placing && isTowerDestroyed && cell.classList.contains('destroyed-structure')) {
    const repairCost = 1500;
    const towerType = aaTurret ? 'üóº Torre Anti-A√©rea' : 'üõ°Ô∏è Torre Desviadora';
    
    const confirmRepair = confirm(
      `üîß REPARAR TORRE\n\n` +
      `${towerType}\n` +
      `Estado: üî• Destruida (0/150 HP)\n\n` +
      `üí∞ Costo: ${repairCost} oro\n` +
      `üíµ Tu oro: ${state.resources.gold}\n\n` +
      `¬øDeseas reparar esta torre?`
    );
    
    if (confirmRepair) {
      if (state.resources.gold < repairCost) {
        return alert(`‚ùå No tienes suficiente oro.\n\nüí∞ Necesitas: ${repairCost}\nüíµ Tienes: ${state.resources.gold}\nüî¥ Faltan: ${repairCost - state.resources.gold}`);
      }
      
      // Reparar la torre
      await repairTower(r, c, aaTurret, deflector, repairCost);
    }
    return;
  }
  
  // Si hay una estructura y es mi aldea, preguntar si quiere moverla
  if (own && !state.placing && (cell.classList.contains('gold-mine') || cell.classList.contains('rocket-launcher') || cell.classList.contains('super-rocket-launcher') || cell.classList.contains('aa-turret') || cell.classList.contains('statue') || cell.classList.contains('flower') || cell.classList.contains('deflector-tower'))) {
    const move = confirm('¬øQuieres mover esta estructura a otra ubicaci√≥n?');
    if (move) {
      // Determinar tipo de estructura
      let structureType = null;
      if (cell.classList.contains('gold-mine')) structureType = 'mine';
      else if (cell.classList.contains('rocket-launcher')) structureType = 'rocketLauncher';
      else if (cell.classList.contains('super-rocket-launcher')) structureType = 'superRocketLauncher';
      else if (cell.classList.contains('aa-turret')) structureType = 'aaTurret';
      else if (cell.classList.contains('statue')) structureType = 'statue';
      else if (cell.classList.contains('flower')) structureType = 'flower';
      else if (cell.classList.contains('deflector-tower')) structureType = 'deflectorTower';
      
      // Guardar info de la estructura a mover
      state.moving = { type: structureType, fromRow: r, fromCol: c };
      alert('Ahora haz click en la nueva ubicaci√≥n para mover la estructura');
    }
    return;
  }
  
  if (cell.classList.contains('gold-mine') || cell.classList.contains('rocket-launcher') || cell.classList.contains('aa-turret') || cell.classList.contains('statue') || cell.classList.contains('flower') || cell.classList.contains('deflector-tower')) {
    return alert('Ya hay una estructura aqu√≠');
  }
  
  // Si est√° en modo mover, completar el movimiento
  if (own && state.moving) {
    if (cell.classList.contains('damaged')) {
      return alert('No puedes mover una estructura a un √°rea da√±ada.');
    }
    await moveStructure(state.moving.fromRow, state.moving.fromCol, r, c, state.moving.type);
    state.moving = null;
    return;
  }
  
  // BUGFIX: No permitir colocar estructuras en bloques destruidos
  if (cell.classList.contains('damaged') && (state.placing === 'mine' || state.placing === 'rocketLauncher' || state.placing === 'superRocketLauncher' || state.placing === 'aaTurret' || state.placing === 'statue' || state.placing === 'flower' || state.placing === 'deflectorTower')) {
    return alert('No puedes construir en un √°rea da√±ada. Rep√°rala primero con una pala.');
  }
 
  if (own && state.placing === 'mine') await buildMine(r, c, cell);
  else if (own && state.placing === 'rocketLauncher') await buildRocketLauncher(r, c, cell);
  else if (own && state.placing === 'superRocketLauncher') await buildSuperRocketLauncher(r, c, cell);
  else if (own && state.placing === 'aaTurret') await buildAATurret(r, c, cell);
  else if (own && state.placing === 'deflectorTower') await buildDeflectorTower(r, c, cell);
  else if (own && state.placing === 'statue') await placeStatue(r, c, cell);
  else if (own && state.placing === 'flower') await placeFlower(r, c, cell);
  else if (own && state.placing && state.placing.startsWith('shovel') && cell.classList.contains('damaged')) {
    const shovelLevel = parseInt(state.placing.split('_')[1]) || 1;
    await repair(r, c, cell, shovelLevel);
  }
  else if (!own && state.placing === 'bomb') await launchBomb(r, c);
  else if (!own && state.placing === 'rocket_attack') await launchRocketAttack(r, c);
  else if (!own && state.placing === 'super_rocket_attack') await launchSuperRocketAttack(r, c);
  else if (!own && state.placing === 'bomber_attack') await launchBomberAttack(r, c);
}
// Tower Repair Function
async function repairTower(r, c, aaTurret, deflector, repairCost) {
  loading(true);
  
  // Reducir oro
  state.resources.gold -= repairCost;
  await set(ref(db, `users/${state.user}/resources`), {
    gold: state.resources.gold,
    lastUpdate: Date.now()
  });
  
  // Reparar la torre espec√≠fica
  if (aaTurret) {
    aaTurret.health = 150;
    aaTurret.destroyed = false;
  } else if (deflector) {
    deflector.health = 150;
    deflector.destroyed = false;
  }
  
  // Guardar en Firebase
  await set(ref(db, `users/${state.currentVillage.owner}/buildings`), {
    goldMines: state.buildings.mines,
    rocketLaunchers: state.buildings.rocketLaunchers,
    superRocketLaunchers: state.buildings.superRocketLaunchers,
    aaTurrets: state.buildings.aaTurrets,
    deflectorTowers: state.buildings.deflectorTowers,
    statues: state.buildings.statues,
    flowers: state.buildings.flowers,
    damaged: state.buildings.damaged
  });
  
  // Actualizar visual de la torre espec√≠fica
  const cell = $('islandGrid').querySelector(`[data-row="${r}"][data-col="${c}"]`);
  if (cell) {
    const emoji = aaTurret ? 'üóº' : 'üõ°Ô∏è';
    cell.textContent = emoji;
    cell.style.opacity = '1';
    cell.classList.remove('destroyed-structure');
    
    // Agregar barra de vida
    const healthBarContainer = document.createElement('div');
    healthBarContainer.className = 'health-bar-container';
    
    const healthBar = document.createElement('div');
    healthBar.className = 'health-bar';
    healthBar.style.width = '100%';
    
    const healthText = document.createElement('div');
    healthText.className = 'health-text';
    healthText.textContent = '150/150';
    
    healthBarContainer.appendChild(healthBar);
    cell.appendChild(healthBarContainer);
    cell.appendChild(healthText);
  }
  
  updateUI();
  await addXP(25);
  
  loading(false);
  const towerName = aaTurret ? 'Torre Anti-A√©rea' : 'Torre Desviadora';
  alert(`‚úÖ ¬°${towerName} reparada!\n\nüíö HP Restaurado: 150\n‚ù§Ô∏è HP Actual: 150/150\nüí∞ Oro gastado: ${repairCost}\n‚≠ê +25 XP`);
}
// Castle Repair Function
async function showCastleRepairMenu() {
  const currentHealth = state.currentVillage.castleHealth !== undefined ? state.currentVillage.castleHealth : 500;
  const maxHealth = state.currentVillage.castleMaxHealth || 500;
  
  if (currentHealth >= maxHealth) {
    return alert('üè∞ El castillo est√° en perfectas condiciones.\n\n‚ù§Ô∏è HP: ' + currentHealth + ' / ' + maxHealth);
  }
  
  const healthNeeded = maxHealth - currentHealth;
  const repairCost = 2500;
  
  const confirmRepair = confirm(
    `üîß REPARAR CASTILLO\n\n` +
    `‚ù§Ô∏è HP Actual: ${currentHealth} / ${maxHealth}\n` +
    `üíö HP a Restaurar: ${healthNeeded}\n\n` +
    `üí∞ Costo: ${repairCost} oro\n` +
    `üíµ Tu oro: ${state.resources.gold}\n\n` +
    `¬øDeseas reparar el castillo?`
  );
  
  if (!confirmRepair) return;
  
  if (state.resources.gold < repairCost) {
    return alert(`‚ùå No tienes suficiente oro.\n\nüí∞ Necesitas: ${repairCost}\nüíµ Tienes: ${state.resources.gold}\nüî¥ Faltan: ${repairCost - state.resources.gold}`);
  }
  
  loading(true);
  
  // Reducir oro
  state.resources.gold -= repairCost;
  await set(ref(db, `users/${state.user}/resources`), {
    gold: state.resources.gold,
    lastUpdate: Date.now()
  });
  
  // Restaurar HP del castillo
  state.currentVillage.castleHealth = maxHealth;
  const villageRef = ref(db, `villages/${state.currentVillage.id}`);
  const villageSnap = await get(villageRef);
  if (villageSnap.exists()) {
    const villageData = villageSnap.val();
    await set(villageRef, {
      ...villageData,
      castleHealth: maxHealth
    });
  }
  
  // Actualizar visual
  const castleCell = $('islandGrid').querySelector(`[data-row="10"][data-col="10"]`);
  if (castleCell) {
    if (castleCell.classList.contains('destroyed-castle')) {
      // Si estaba destruido, restaurarlo
      castleCell.textContent = 'üè∞';
      castleCell.classList.remove('destroyed-castle');
      if (state.currentVillage.owner === state.user) {
        castleCell.classList.add('my-castle');
      } else {
        castleCell.classList.add('enemy-castle');
      }
      
      // Detener humo
      const smokeId = 'destroyed_castle_island';
      if (state.intervals.particles[smokeId]) {
        clearInterval(state.intervals.particles[smokeId]);
        delete state.intervals.particles[smokeId];
      }
    }
    
    // Remover clase de da√±o (castillo completamente reparado)
    castleCell.classList.remove('castle-damaged');
    
    // Remover barras de vida (castillo con HP completo no muestra barra)
    const healthBar = castleCell.querySelector('.health-bar-container');
    const healthText = castleCell.querySelector('.health-text');
    if (healthBar) healthBar.remove();
    if (healthText) healthText.remove();
  }
  updateUI();
  
  await addXP(50);
  
  loading(false);
  alert(`‚úÖ ¬°Castillo reparado!\n\nüíö HP Restaurado: ${healthNeeded}\n‚ù§Ô∏è HP Actual: ${maxHealth} / ${maxHealth}\nüí∞ Oro gastado: ${repairCost}\n‚≠ê +50 XP`);
}
// Building Functions
async function buildMine(r, c, cell) {
  loading(true);
  state.buildings.mines.push({row: r, col: c});
  await set(ref(db, `users/${state.user}/buildings`), {
    goldMines: state.buildings.mines,
    rocketLaunchers: state.buildings.rocketLaunchers,
    superRocketLaunchers: state.buildings.superRocketLaunchers,
    aaTurrets: state.buildings.aaTurrets,
    deflectorTowers: state.buildings.deflectorTowers,
    statues: state.buildings.statues,
    flowers: state.buildings.flowers,
    damaged: state.buildings.damaged
  });
  cell.classList.add('gold-mine');
  cell.textContent = '‚õèÔ∏è';
  await addXP(25);
  state.placing = null;
  updateShop();
  startGoldGen();
  if (state.buildings.mines.length === 1) await unlockAchievement('firstMine');
  alert('¬°Mina construida! +25 XP');
  loading(false);
}
async function buildRocketLauncher(r, c, cell) {
  loading(true);
  state.buildings.rocketLaunchers.push({row: r, col: c});
  await set(ref(db, `users/${state.user}/buildings`), {
    goldMines: state.buildings.mines,
    rocketLaunchers: state.buildings.rocketLaunchers,
    superRocketLaunchers: state.buildings.superRocketLaunchers,
    aaTurrets: state.buildings.aaTurrets,
    deflectorTowers: state.buildings.deflectorTowers,
    statues: state.buildings.statues,
    flowers: state.buildings.flowers,
    damaged: state.buildings.damaged
  });
  cell.classList.add('rocket-launcher');
  cell.textContent = 'üöÄ';
  await addXP(100);
  state.placing = null;
  updateShop();
  if (state.buildings.rocketLaunchers.length === 1) await unlockAchievement('rocketLauncher');
  alert('¬°Lanza Cohetes construido! +100 XP');
  loading(false);
}
async function buildSuperRocketLauncher(r, c, cell) {
  loading(true);
  state.buildings.superRocketLaunchers.push({row: r, col: c});
  await set(ref(db, `users/${state.user}/buildings`), {
    goldMines: state.buildings.mines,
    rocketLaunchers: state.buildings.rocketLaunchers,
    superRocketLaunchers: state.buildings.superRocketLaunchers,
    aaTurrets: state.buildings.aaTurrets,
    deflectorTowers: state.buildings.deflectorTowers,
    statues: state.buildings.statues,
    flowers: state.buildings.flowers,
    damaged: state.buildings.damaged
  });
  cell.classList.add('super-rocket-launcher');
  cell.textContent = 'üí•';
  await addXP(200);
  
  // Eliminar del inventario
  const items = (await get(ref(db, `users/${state.user}/inventory/items`))).val() || [];
  const launcherIndex = items.indexOf('superRocketLauncher');
  if (launcherIndex !== -1) {
    items.splice(launcherIndex, 1);
    await set(ref(db, `users/${state.user}/inventory/items`), items);
    state.inventory = items;
  }
  
  state.placing = null;
  updateShop();
  alert('¬°Super Lanzador construido! +200 XP ‚ö†Ô∏è CUIDADO: Da√±a tu aldea al despegar');
  loading(false);
}
async function buildAATurret(r, c, cell) {
  loading(true);
  state.buildings.aaTurrets.push({row: r, col: c, health: 150});
  await set(ref(db, `users/${state.user}/buildings`), {
    goldMines: state.buildings.mines,
    rocketLaunchers: state.buildings.rocketLaunchers,
    superRocketLaunchers: state.buildings.superRocketLaunchers,
    aaTurrets: state.buildings.aaTurrets,
    deflectorTowers: state.buildings.deflectorTowers,
    statues: state.buildings.statues,
    flowers: state.buildings.flowers,
    damaged: state.buildings.damaged
  });
  cell.classList.add('aa-turret');
  cell.textContent = 'üóº';
  await addXP(80);
  state.placing = null;
  updateShop();
  alert('¬°Torreta Anti-A√©rea construida! +80 XP');
  loading(false);
}
async function buildDeflectorTower(r, c, cell) {
  loading(true);
  state.buildings.deflectorTowers.push({row: r, col: c, health: 150});
  await set(ref(db, `users/${state.user}/buildings`), {
    goldMines: state.buildings.mines,
    rocketLaunchers: state.buildings.rocketLaunchers,
    superRocketLaunchers: state.buildings.superRocketLaunchers,
    aaTurrets: state.buildings.aaTurrets,
    deflectorTowers: state.buildings.deflectorTowers,
    statues: state.buildings.statues,
    flowers: state.buildings.flowers,
    damaged: state.buildings.damaged
  });
  cell.classList.add('deflector-tower');
  cell.textContent = 'üõ°Ô∏è';
  await addXP(75);
  
  // Eliminar del inventario
  const items = (await get(ref(db, `users/${state.user}/inventory/items`))).val() || [];
  const towerIndex = items.indexOf('deflectorTower');
  if (towerIndex !== -1) {
    items.splice(towerIndex, 1);
    await set(ref(db, `users/${state.user}/inventory/items`), items);
    state.inventory = items;
  }
  
  state.placing = null;
  updateShop();
  if (state.buildings.deflectorTowers.length === 1) await unlockAchievement('deflectorTower');
  alert('¬°Torre Desviadora construida! Desv√≠a cohetes enemigos. +75 XP');
  loading(false);
}
async function placeStatue(r, c, cell) {
  loading(true);
  state.buildings.statues.push({row: r, col: c});
  await set(ref(db, `users/${state.user}/buildings`), {
    goldMines: state.buildings.mines,
    rocketLaunchers: state.buildings.rocketLaunchers,
    superRocketLaunchers: state.buildings.superRocketLaunchers,
    aaTurrets: state.buildings.aaTurrets,
    deflectorTowers: state.buildings.deflectorTowers,
    statues: state.buildings.statues,
    flowers: state.buildings.flowers,
    damaged: state.buildings.damaged
  });
  cell.classList.add('statue');
  cell.textContent = 'üóø';
  await addXP(50);
 
  const items = (await get(ref(db, `users/${state.user}/inventory/items`))).val() || [];
  items.splice(items.indexOf('statue'), 1);
  await set(ref(db, `users/${state.user}/inventory/items`), items);
 
  state.placing = null;
  alert('¬°Estatua Moai colocada! +50 XP');
  loading(false);
}
async function placeFlower(r, c, cell) {
  loading(true);
  state.buildings.flowers.push({row: r, col: c});
  await set(ref(db, `users/${state.user}/buildings`), {
    goldMines: state.buildings.mines,
    rocketLaunchers: state.buildings.rocketLaunchers,
    superRocketLaunchers: state.buildings.superRocketLaunchers,
    aaTurrets: state.buildings.aaTurrets,
    deflectorTowers: state.buildings.deflectorTowers,
    statues: state.buildings.statues,
    flowers: state.buildings.flowers,
    damaged: state.buildings.damaged
  });
  cell.classList.add('flower');
  cell.textContent = 'üå∏';
  await addXP(30);
 
  const items = (await get(ref(db, `users/${state.user}/inventory/items`))).val() || [];
  items.splice(items.indexOf('flower'), 1);
  await set(ref(db, `users/${state.user}/inventory/items`), items);
 
  state.placing = null;
  alert('¬°Flor decorativa colocada! +30 XP');
  loading(false);
}
async function moveStructure(fromRow, fromCol, toRow, toCol, type) {
  loading(true);
  
  const grid = $('islandGrid');
  const oldCell = grid.querySelector(`[data-row="${fromRow}"][data-col="${fromCol}"]`);
  const newCell = grid.querySelector(`[data-row="${toRow}"][data-col="${toCol}"]`);
  
  // Determinar el array y clase correspondiente
  let buildingArray, className, emoji;
  if (type === 'mine') {
    buildingArray = state.buildings.mines;
    className = 'gold-mine';
    emoji = '‚õèÔ∏è';
  } else if (type === 'rocketLauncher') {
    buildingArray = state.buildings.rocketLaunchers;
    className = 'rocket-launcher';
    emoji = 'üöÄ';
  } else if (type === 'superRocketLauncher') {
    buildingArray = state.buildings.superRocketLaunchers;
    className = 'super-rocket-launcher';
    emoji = 'üí•';
  } else if (type === 'aaTurret') {
    buildingArray = state.buildings.aaTurrets;
    className = 'aa-turret';
    emoji = 'üóº';
  } else if (type === 'deflectorTower') {
    buildingArray = state.buildings.deflectorTowers;
    className = 'deflector-tower';
    emoji = 'üõ°Ô∏è';
  } else if (type === 'statue') {
    buildingArray = state.buildings.statues;
    className = 'statue';
    emoji = 'üóø';
  } else if (type === 'flower') {
    buildingArray = state.buildings.flowers;
    className = 'flower';
    emoji = 'üå∏';
  }
  
  // Encontrar y actualizar la estructura en el array
  const structureIndex = buildingArray.findIndex(s => s.row === fromRow && s.col === fromCol);
  if (structureIndex !== -1) {
    // Preservar todas las propiedades (health, destroyed, etc.) al mover
    const oldStructure = buildingArray[structureIndex];
    buildingArray[structureIndex] = { 
      ...oldStructure,
      row: toRow, 
      col: toCol 
    };
  }
  
  // Actualizar en Firebase
  await set(ref(db, `users/${state.user}/buildings`), {
    goldMines: state.buildings.mines,
    rocketLaunchers: state.buildings.rocketLaunchers,
    superRocketLaunchers: state.buildings.superRocketLaunchers,
    aaTurrets: state.buildings.aaTurrets,
    deflectorTowers: state.buildings.deflectorTowers,
    statues: state.buildings.statues,
    flowers: state.buildings.flowers,
    damaged: state.buildings.damaged
  });
  
  // Actualizar visualmente
  oldCell.classList.remove(className);
  oldCell.textContent = '';
  
  // Remover barras de vida de la celda antigua
  const oldHealthBar = oldCell.querySelector('.health-bar-container');
  const oldHealthText = oldCell.querySelector('.health-text');
  if (oldHealthBar) oldHealthBar.remove();
  if (oldHealthText) oldHealthText.remove();
  
  newCell.classList.add(className);
  newCell.textContent = emoji;
  
  // Si es una torre, agregar barra de vida
  if (type === 'aaTurret' || type === 'deflectorTower') {
    const structure = buildingArray[structureIndex];
    const health = structure.health !== undefined ? structure.health : 150;
    const maxHealth = 150;
    const isDestroyed = structure.destroyed || health <= 0;
    
    if (!isDestroyed) {
      // Agregar barra de vida
      const healthBarContainer = document.createElement('div');
      healthBarContainer.className = 'health-bar-container';
      
      const healthBar = document.createElement('div');
      healthBar.className = 'health-bar';
      const healthPercent = (health / maxHealth) * 100;
      healthBar.style.width = healthPercent + '%';
      
      if (healthPercent <= 25) {
        healthBar.classList.add('low');
      } else if (healthPercent <= 50) {
        healthBar.classList.add('medium');
      }
      
      const healthText = document.createElement('div');
      healthText.className = 'health-text';
      healthText.textContent = `${health}/${maxHealth}`;
      
      healthBarContainer.appendChild(healthBar);
      newCell.appendChild(healthBarContainer);
      newCell.appendChild(healthText);
    } else {
      // Torre destruida
      newCell.classList.add('destroyed-structure');
      newCell.textContent = 'üî•';
      newCell.style.opacity = '0.6';
    }
  }
  
  alert('¬°Estructura movida exitosamente!');
  loading(false);
}
async function repair(r, c, cell, shovelLevel = 1) {
  loading(true);
  
  // Obtener celdas da√±adas cercanas seg√∫n el nivel de la pala
  const grid = $('islandGrid');
  const repairedCells = [];
  const cellsToRepair = [];
  
  // Primero, reparar la celda clickeada
  cellsToRepair.push({row: r, col: c, cell: cell});
  
  // Buscar celdas da√±adas adicionales seg√∫n el nivel
  if (shovelLevel > 1) {
    const directions = [
      {dr: -1, dc: 0}, {dr: 1, dc: 0}, {dr: 0, dc: -1}, {dr: 0, dc: 1},
      {dr: -1, dc: -1}, {dr: -1, dc: 1}, {dr: 1, dc: -1}, {dr: 1, dc: 1}
    ];
    
    let found = 1;
    let searchRadius = 1;
    
    while (found < shovelLevel && searchRadius <= 3) {
      for (const dir of directions) {
        if (found >= shovelLevel) break;
        
        const nr = r + (dir.dr * searchRadius);
        const nc = c + (dir.dc * searchRadius);
        
        if (nr >= 0 && nr < 20 && nc >= 0 && nc < 20) {
          const nearCell = grid.querySelector(`[data-row="${nr}"][data-col="${nc}"]`);
          if (nearCell && nearCell.classList.contains('damaged') && 
              !cellsToRepair.some(ct => ct.row === nr && ct.col === nc)) {
            cellsToRepair.push({row: nr, col: nc, cell: nearCell});
            found++;
            if (found >= shovelLevel) break;
          }
        }
      }
      searchRadius++;
    }
  }
  
  // Reparar todas las celdas encontradas (solo terreno, NO torres)
  cellsToRepair.forEach(({row, col, cell}) => {
    // Solo reparar terreno da√±ado, no torres destruidas
    if (cell.classList.contains('damaged') && !cell.classList.contains('destroyed-structure')) {
      state.buildings.damaged = state.buildings.damaged.filter(d => !(d.row === row && d.col === col));
      cell.classList.remove('damaged');
      repairedCells.push({row, col});
    }
  });
  
  await set(ref(db, `users/${state.currentVillage.owner}/buildings`), {
    goldMines: state.buildings.mines,
    rocketLaunchers: state.buildings.rocketLaunchers,
    superRocketLaunchers: state.buildings.superRocketLaunchers,
    aaTurrets: state.buildings.aaTurrets,
    deflectorTowers: state.buildings.deflectorTowers,
    statues: state.buildings.statues,
    flowers: state.buildings.flowers,
    damaged: state.buildings.damaged
  });
  
  const xpGained = cellsToRepair.length * 10;
  await addXP(xpGained);
 
  const items = (await get(ref(db, `users/${state.user}/inventory/items`))).val() || [];
  const shovelItem = items.find(item => item.startsWith('shovel'));
  if (shovelItem) {
    items.splice(items.indexOf(shovelItem), 1);
  }
  await set(ref(db, `users/${state.user}/inventory/items`), items);
 
  state.placing = null;
  alert(`¬°${cellsToRepair.length} √°rea(s) reparada(s)! +${xpGained} XP`);
  loading(false);
}
// Attack Functions
async function launchBomb(r, c) {
  // Prevenir m√∫ltiples clicks
  if (state.dragLocked) return;
  
  loading(true);
  
  // Bloquear movimiento del mapa y m√°s clicks
  state.dragLocked = true;
  $('islandViewport').style.cursor = 'default';
  
  // ESCRIBIR EVENTO DE ATAQUE PARA ESPECTADORES
  await set(ref(db, `villages/${state.currentVillage.id}/currentAttack`), {
    active: true,
    type: 'bomb',
    targetRow: r,
    targetCol: c,
    timestamp: Date.now()
  });
  
  // Obtener la celda objetivo
  const targetCell = $('islandGrid').querySelector(`[data-row="${r}"][data-col="${c}"]`);
  if (!targetCell) {
    state.dragLocked = false;
    $('islandViewport').style.cursor = 'grab';
    loading(false);
    return;
  }
  
  const targetRect = targetCell.getBoundingClientRect();
  const targetCenterX = targetRect.left + targetRect.width / 2;
  const targetCenterY = targetRect.top + targetRect.height / 2;
  
  // Crear bomba cayendo desde arriba
  const bomb = document.createElement('div');
  bomb.style.position = 'fixed';
  bomb.style.fontSize = '30px';
  bomb.style.left = targetCenterX - 15 + 'px';
  bomb.style.top = '-50px';
  bomb.style.zIndex = '10001';
  bomb.textContent = 'üí£';
  bomb.style.transition = 'top 0.8s ease-in';
  document.body.appendChild(bomb);
  
  // Animar ca√≠da
  setTimeout(() => {
    bomb.style.top = targetCenterY - 15 + 'px';
  }, 50);
  
  // Esperar a que caiga y explotar
  await new Promise(resolve => setTimeout(resolve, 850));
  
  bomb.remove();
  
  // Crear explosi√≥n visual y sonora
  createExplosion(targetCenterX, targetCenterY);
  
  // Efecto de temblor
  const viewport = $('islandViewport');
  viewport.classList.add('shake');
  setTimeout(() => viewport.classList.remove('shake'), 300);
  
  // Peque√±o delay para que los espectadores vean la animaci√≥n
  await new Promise(resolve => setTimeout(resolve, 100));
  
  // Variable para verificar si el castillo fue impactado
  let castleHit = false;
  
  for (let dx = -1; dx <= 1; dx++) {
    for (let dy = -1; dy <= 1; dy++) {
      const nr = r + dx, nc = c + dy;
      if (nr >= 0 && nr < 20 && nc >= 0 && nc < 20) {
        // Verificar si impact√≥ el castillo
        if (nr === 10 && nc === 10) {
          castleHit = true;
          continue; // No da√±ar el castillo directamente, solo reducir su salud
        }
        
        // Verificar si hay alguna estructura en esta posici√≥n
        const hasMine = state.buildings.mines.some(m => m.row === nr && m.col === nc);
        const hasRocket = state.buildings.rocketLaunchers.some(rl => rl.row === nr && rl.col === nc);
        const aaTurret = state.buildings.aaTurrets.find(aa => aa.row === nr && aa.col === nc);
        const deflector = state.buildings.deflectorTowers.find(dt => dt.row === nr && dt.col === nc);
        const hasStatue = state.buildings.statues.some(s => s.row === nr && s.col === nc);
        const hasFlower = state.buildings.flowers.some(f => f.row === nr && f.col === nc);
        const alreadyDamaged = state.buildings.damaged.some(d => d.row === nr && d.col === nc);
        
        // Da√±ar Torre Anti-A√©rea
        if (aaTurret) {
          aaTurret.health = (aaTurret.health !== undefined ? aaTurret.health : 150) - 250;
          if (aaTurret.health <= 0) {
            aaTurret.health = 0;
            aaTurret.destroyed = true;
          }
        }
        // Da√±ar Torre Desviadora
        else if (deflector) {
          deflector.health = (deflector.health !== undefined ? deflector.health : 150) - 250;
          if (deflector.health <= 0) {
            deflector.health = 0;
            deflector.destroyed = true;
          }
        }
        // Da√±ar terreno
        else if (!hasMine && !hasRocket && !hasStatue && !hasFlower && !alreadyDamaged) {
          const target = $('islandGrid').querySelector(`[data-row="${nr}"][data-col="${nc}"]`);
          if (target) {
            state.buildings.damaged.push({row: nr, col: nc});
            target.classList.add('damaged');
          }
        }
      }
    }
  }
  
  // Si el castillo fue impactado, reducir su salud
  if (castleHit) {
    const villageRef = ref(db, `villages/${state.currentVillage.id}`);
    const villageSnap = await get(villageRef);
    if (villageSnap.exists()) {
      const villageData = villageSnap.val();
      let castleHealth = villageData.castleHealth !== undefined ? villageData.castleHealth : 500;
      const maxHealth = villageData.castleMaxHealth || 500;
      castleHealth = Math.max(0, castleHealth - 250); // Cohete hace 250 de da√±o
      
      await set(villageRef, {
        ...villageData,
        castleHealth: castleHealth
      });
      
      state.currentVillage.castleHealth = castleHealth;
      
      // Actualizar visual del castillo
      const castleCell = $('islandGrid').querySelector(`[data-row="10"][data-col="10"]`);
      if (castleCell) {
        const healthPercent = (castleHealth / maxHealth) * 100;
        
        if (castleHealth <= 0) {
          castleCell.textContent = 'üï≥Ô∏è';
          castleCell.classList.remove('my-castle', 'enemy-castle', 'castle-damaged');
          castleCell.classList.add('destroyed-castle');
          // Remover barra de vida
          const healthBar = castleCell.querySelector('.health-bar-container');
          const healthText = castleCell.querySelector('.health-text');
          if (healthBar) healthBar.remove();
          if (healthText) healthText.remove();
          showXPNotification(0, window.innerWidth / 2 - 100, window.innerHeight / 2, 'üí• ¬°CASTILLO DESTRUIDO!');
        } else {
          // Actualizar clase de da√±o
          if (healthPercent <= 50) {
            castleCell.classList.add('castle-damaged');
          } else {
            castleCell.classList.remove('castle-damaged');
          }
          
          // Crear barra de vida si no existe
          if (!castleCell.querySelector('.health-bar-container')) {
            const healthBarContainer = document.createElement('div');
            healthBarContainer.className = 'health-bar-container';
            healthBarContainer.id = 'castle-health-bar-container';
            
            const healthBar = document.createElement('div');
            healthBar.className = 'health-bar';
            healthBar.id = 'castle-health-bar';
            
            const healthText = document.createElement('div');
            healthText.className = 'health-text';
            healthText.id = 'castle-health-text';
            
            healthBarContainer.appendChild(healthBar);
            castleCell.appendChild(healthBarContainer);
            castleCell.appendChild(healthText);
          }
          
          // Actualizar barra de vida
          updateCastleHealthBar();
          
          showXPNotification(0, window.innerWidth / 2 - 100, window.innerHeight / 2, `üöÄ -250 HP | ${castleHealth}/${maxHealth}`);
        }
      }
    }
  }
  await set(ref(db, `users/${state.currentVillage.owner}/buildings`), {
    goldMines: state.buildings.mines,
    rocketLaunchers: state.buildings.rocketLaunchers,
    superRocketLaunchers: state.buildings.superRocketLaunchers,
    aaTurrets: state.buildings.aaTurrets,
    deflectorTowers: state.buildings.deflectorTowers,
    statues: state.buildings.statues,
    flowers: state.buildings.flowers,
    damaged: state.buildings.damaged
  });
  
  // Actualizar visual de torres (destruidas o da√±adas)
  updateTowerHealthVisuals();
  
  // Dar XP al atacante (state.user), no al due√±o de la aldea
  const attackerLevelSnap = await get(ref(db, `users/${state.user}/level`));
  if (attackerLevelSnap.exists()) {
    let attackerLevel = attackerLevelSnap.val();
    attackerLevel.xp = (attackerLevel.xp || 0) + 30;
    
    // Verificar si sube de nivel
    while (attackerLevel.xp >= attackerLevel.needed && attackerLevel.level < 20) {
      attackerLevel.xp -= attackerLevel.needed;
      attackerLevel.level++;
      attackerLevel.needed = attackerLevel.level * 100;
    }
    
    if (attackerLevel.level >= 20) attackerLevel.xp = Math.min(attackerLevel.xp, attackerLevel.needed - 1);
    
    await set(ref(db, `users/${state.user}/level`), attackerLevel);
  }
  
  state.attacking = false;
  state.placing = null;
  state.dragLocked = false;
  $('islandViewport').style.cursor = 'grab';
  await set(ref(db, `villages/${state.currentVillage.id}/underAttack`), false);
  await set(ref(db, `villages/${state.currentVillage.id}/currentAttack`), { active: false });
  
  // Mostrar notificaci√≥n de XP en el centro de la pantalla
  showXPNotification(30, window.innerWidth / 2 - 50, window.innerHeight / 2);
  
  loading(false);
}
async function launchRocketAttack(r, c) {
  // Prevenir m√∫ltiples clicks
  if (state.dragLocked) return;
  
  // Bloquear movimiento del mapa y m√°s clicks
  state.dragLocked = true;
  $('islandViewport').style.cursor = 'default';
  
  // Verificar si hay un bombardero activo
  if (state.bomberActive) {
    alert('¬°Espera a que termine el bombardeo antes de lanzar un cohete!');
    state.attacking = false;
    state.placing = null;
    state.dragLocked = false;
    $('islandViewport').style.cursor = 'grab';
    await set(ref(db, `villages/${state.currentVillage.id}/underAttack`), false);
    loading(false);
    return;
  }
  
  // Verificar si el usuario tiene munici√≥n de cohetes
  const rocketAmmoSnap = await get(ref(db, `users/${state.user}/inventory/rocketAmmo`));
  const rocketAmmo = rocketAmmoSnap.exists() ? rocketAmmoSnap.val() : 0;
  
  if (rocketAmmo <= 0) {
    alert('¬°Necesitas munici√≥n de cohetes para realizar este ataque! Compra cohetes en la tienda global.');
    state.attacking = false;
    state.placing = null;
    state.dragLocked = false;
    $('islandViewport').style.cursor = 'grab';
    await set(ref(db, `villages/${state.currentVillage.id}/underAttack`), false);
    loading(false);
    return;
  }
  
  // NUEVA L√ìGICA: Verificar si hay Torre Desviadora que pueda interceptar
  const deflectorTowers = state.buildings.deflectorTowers || [];
  let deflectorTower = null;
  
  for (const tower of deflectorTowers) {
    // Verificar que la torre NO est√© destruida
    const isDestroyed = tower.destroyed || (tower.health !== undefined && tower.health <= 0);
    if (isDestroyed) continue; // Torre destruida no puede desviar
    
    // Calcular distancia entre el cohete y la torre
    const distance = Math.sqrt(Math.pow(r - tower.row, 2) + Math.pow(c - tower.col, 2));
    
    // Si la torre est√° dentro del rango de 5 celdas, puede desviar el cohete
    if (distance <= 5) {
      deflectorTower = tower;
      break;
    }
  }
  
  // Restar una munici√≥n
  await set(ref(db, `users/${state.user}/inventory/rocketAmmo`), rocketAmmo - 1);

  // SISTEMA DE GRABACI√ìN PARA ESPECTADORES
  const attackActions = [];
  const recordAction = (type, data, delay = 0) => {
    attackActions.push({ type, ...data, delay });
  };

  // Guardar datos del ataque y zoom actual
  const attackTarget = {row: r, col: c, owner: state.currentVillage.owner, id: state.currentVillage.id};
  const savedZoom = {
    x: state.view.island.x,
    y: state.view.island.y,
    scale: state.view.island.scale
  };
 
  // Obtener datos de mi aldea para el lanza cohetes
  const myBuildingsSnap = await get(ref(db, `users/${state.user}/buildings`));
  const myBuildings = myBuildingsSnap.exists() ? myBuildingsSnap.val() : {};
  const myRocketLaunchers = myBuildings.rocketLaunchers || [];
 
  if (myRocketLaunchers.length === 0) {
    alert('¬°Necesitas construir un lanza cohetes en tu aldea primero!');
    state.attacking = false;
    state.placing = null;
    state.dragLocked = false;
    $('islandViewport').style.cursor = 'grab';
    await set(ref(db, `villages/${attackTarget.id}/underAttack`), false);
    return;
  }
 
  const myRocketLauncher = myRocketLaunchers[0];
 

  // Paso 1: Transici√≥n a mi aldea
  recordAction('transition_attacker', { attacker: state.user }, 0);
  
  $('fade').style.opacity = 1;
  await new Promise(resolve => setTimeout(resolve, 400));
 
  state.skipCentering = true;
  await openIsland(state.user);

  // OCULTAR BOTONES DE UI DURANTE LA ANIMACI√ìN
  $('backButton').style.display = 'none';
  $('inventoryButton').style.display = 'none';
  $('shopButton').style.display = 'none';
  $('marketButton').style.display = 'none';
  $('islandAchievementsButton').style.display = 'none';
  $('islandTextureToggle').style.display = 'none';
  $('islandGridToggle').style.display = 'none';

  // Centrar en el lanza cohetes sin animaci√≥n
  const rocketLauncherCell = $('islandGrid').querySelector(`[data-row="${myRocketLauncher.row}"][data-col="${myRocketLauncher.col}"]`);
  if (!rocketLauncherCell) {
    alert('Error: No se pudo encontrar el lanza cohetes');
    // RESTAURAR BOTONES DE UI en caso de error
    $('backButton').style.display = 'block';
    $('inventoryButton').style.display = state.user === state.currentVillage.owner ? 'block' : 'none';
    $('shopButton').style.display = state.user === state.currentVillage.owner ? 'block' : 'none';
    $('marketButton').style.display = state.user === state.currentVillage.owner ? 'block' : 'none';
    $('attackButton').style.display = state.user !== state.currentVillage.owner ? 'block' : 'none';
    $('islandAchievementsButton').style.display = 'block';
    $('islandTextureToggle').style.display = 'block';
    $('islandGridToggle').style.display = 'block';
    loading(false);
    return;
  }
 
  const gridPadding = 200;
  const cellSize = 40;
  const gap = 2;
  const rocketWorldX = gridPadding + myRocketLauncher.col * (cellSize + gap) + cellSize / 2;
  const rocketWorldY = gridPadding + myRocketLauncher.row * (cellSize + gap) + cellSize / 2;
 
  const viewportRect = $('islandViewport').getBoundingClientRect();
  const centerX = viewportRect.width / 2;
  const centerY = viewportRect.height / 2;
 
  const currentScale = state.view.island.scale;
  state.view.island.x = centerX - rocketWorldX * currentScale;
  state.view.island.y = centerY - rocketWorldY * currentScale;
  $('islandWorld').style.transition = '';
  updateTransform('island');
 
  setTimeout(() => $('fade').style.opacity = 0, 100);
 
  // Paso 3: Lanzar cohete hacia arriba
  await new Promise(resolve => setTimeout(resolve, 500));
  
  // GRABAR LANZAMIENTO DEL COHETE
  recordAction('rocket_launch', { 
    launcherRow: myRocketLauncher.row, 
    launcherCol: myRocketLauncher.col 
  }, 500);
 
  // Obtener la posici√≥n actualizada del lanza cohetes
  const updatedRocketLauncherCell = $('islandGrid').querySelector(`[data-row="${myRocketLauncher.row}"][data-col="${myRocketLauncher.col}"]`);
  const updatedRect = updatedRocketLauncherCell.getBoundingClientRect();
 
  // Reproducir sonido de lanzamiento
  const rocketSound = $('rocketSound');
  rocketSound.currentTime = 0;
  rocketSound.volume = 0.5;
  rocketSound.play().catch(e => console.log('Error reproduciendo sonido:', e));
  
  const rocket = document.createElement('div');
  rocket.style.position = 'fixed';
  rocket.style.fontSize = '40px';
  rocket.style.left = updatedRect.left + updatedRect.width / 2 - 20 + 'px';
  rocket.style.top = updatedRect.top + updatedRect.height / 2 - 20 + 'px';
  rocket.style.zIndex = '10001';
  rocket.textContent = 'üöÄ';
  rocket.style.filter = 'drop-shadow(0 0 10px rgba(255, 100, 0, 0.8))';
  document.body.appendChild(rocket);
 
  // Variables para rastrear la posici√≥n del cohete
  const rocketStartTime = Date.now();
  const rocketDuration = 3500; // Duraci√≥n m√°s larga para el despegue
  const rocketStartY = parseFloat(rocket.style.top);
  const rocketStartX = parseFloat(rocket.style.left);
  const rocketEndY = rocketStartY - 1200; // M√°s distancia
 
  // Crear part√≠culas de humo que siguen al cohete
  const smokeInterval = setInterval(() => {
    // Calcular posici√≥n actual del cohete basado en el tiempo
    const elapsed = Date.now() - rocketStartTime;
    const progress = Math.min(elapsed / rocketDuration, 1);
    const easeProgress = progress * progress; // Aceleraci√≥n
    
    const currentRocketY = rocketStartY - (easeProgress * (rocketStartY - rocketEndY));
    
    // Crear m√∫ltiples part√≠culas por cada intervalo
    for (let i = 0; i < 3; i++) {
      const smoke = document.createElement('div');
      smoke.style.position = 'fixed';
      
      // Posici√≥n inicial en la base del cohete (siguiendo su movimiento)
      smoke.style.left = (rocketStartX + 20 + (Math.random() - 0.5) * 15) + 'px';
      smoke.style.top = (currentRocketY + 35) + 'px'; // Debajo del cohete en movimiento
      
      smoke.style.width = (8 + Math.random() * 12) + 'px';
      smoke.style.height = (8 + Math.random() * 12) + 'px';
      smoke.style.borderRadius = '50%';
      
      // Color gris/blanco para el humo
      const opacity = 0.6 + Math.random() * 0.3;
      const gray = 180 + Math.random() * 75;
      smoke.style.background = `rgba(${gray}, ${gray}, ${gray}, ${opacity})`;
      smoke.style.boxShadow = `0 0 8px rgba(255, 255, 255, 0.5)`;
      smoke.style.zIndex = '10000';
      smoke.style.pointerEvents = 'none';
      document.body.appendChild(smoke);
      
      // Animaci√≥n: dispersi√≥n hacia los lados y abajo
      const spreadX = (Math.random() - 0.5) * 50; // M√°s dispersi√≥n horizontal
      const spreadY = Math.random() * 40 + 30; // M√°s dispersi√≥n hacia abajo
      const duration = 1000 + Math.random() * 500;
      
      smoke.style.transition = `all ${duration}ms ease-out`;
      
      setTimeout(() => {
        smoke.style.transform = `translate(${spreadX}px, ${spreadY}px) scale(2.5)`;
        smoke.style.opacity = '0';
      }, 50);
      
      setTimeout(() => smoke.remove(), duration + 100);
    }
  }, 70);
 
  // Animar cohete hacia arriba con animaci√≥n manual m√°s suave
  const animateRocket = () => {
    const elapsed = Date.now() - rocketStartTime;
    const progress = Math.min(elapsed / rocketDuration, 1);
    const easeProgress = progress * progress; // Aceleraci√≥n
    
    const currentY = rocketStartY - (easeProgress * (rocketStartY - rocketEndY));
    rocket.style.top = currentY + 'px';
    
    // Fade out al final
    if (progress > 0.7) {
      rocket.style.opacity = (1 - (progress - 0.7) / 0.3).toString();
    }
    
    if (progress < 1) {
      requestAnimationFrame(animateRocket);
    }
  };
  
  requestAnimationFrame(animateRocket);
 
  await new Promise(resolve => setTimeout(resolve, rocketDuration));
  clearInterval(smokeInterval);
  rocket.remove();
 
  // Paso 4: Transici√≥n a la aldea atacada
  recordAction('transition_target', { target: attackTarget.owner }, 3500);
  
  $('fade').style.opacity = 1;
  await new Promise(resolve => setTimeout(resolve, 400));
 
  // Cargar aldea objetivo desde Firebase (sin restaurar state.buildings manualmente)
  state.skipCentering = true;
  await openIsland(attackTarget.owner);
  state.currentVillage.id = attackTarget.id;
 
  // Restaurar el zoom que ten√≠a el usuario
  $('islandWorld').style.transition = '';
  state.view.island.x = savedZoom.x;
  state.view.island.y = savedZoom.y;
  state.view.island.scale = savedZoom.scale;
  updateTransform('island');

  // Forzar que los botones aparezcan inmediatamente
  $('backButton').style.display = 'block';
  $('islandAchievementsButton').style.display = 'block';
  $('islandTextureToggle').style.display = 'block';
  $('islandGridToggle').style.display = 'block';

  setTimeout(() => $('fade').style.opacity = 0, 100);
 
  // Paso 5: Cohete cae desde arriba en la posici√≥n exacta del ataque
  await new Promise(resolve => setTimeout(resolve, 800));
  
  // GRABAR CA√çDA DEL COHETE
  recordAction('rocket_fall', { 
    targetRow: attackTarget.row, 
    targetCol: attackTarget.col 
  }, 800);
 
  // Calcular la posici√≥n exacta de la celda objetivo en pantalla
  const targetCell = $('islandGrid').querySelector(`[data-row="${attackTarget.row}"][data-col="${attackTarget.col}"]`);
  if (!targetCell) {
    alert('Error: No se pudo encontrar la celda objetivo');
    // RESTAURAR BOTONES DE UI en caso de error
    $('backButton').style.display = 'block';
    $('inventoryButton').style.display = 'none';
    $('shopButton').style.display = 'none';
    $('attackButton').style.display = 'block';
    $('islandAchievementsButton').style.display = 'block';
    $('islandTextureToggle').style.display = 'block';
    $('islandGridToggle').style.display = 'block';
    loading(false);
    return;
  }
 
  const targetRect = targetCell.getBoundingClientRect();
  const targetCenterX = targetRect.left + targetRect.width / 2;
  const targetCenterY = targetRect.top + targetRect.height / 2;
 
  const fallingRocket = document.createElement('div');
  fallingRocket.style.position = 'fixed';
  fallingRocket.style.fontSize = '40px';
  fallingRocket.style.left = targetCenterX - 20 + 'px';
  fallingRocket.style.top = '-100px';
  fallingRocket.style.zIndex = '10001';
  fallingRocket.textContent = 'üöÄ';
  fallingRocket.style.transform = 'rotate(180deg)';
  fallingRocket.style.transition = 'top 1.5s ease-in';
  fallingRocket.style.filter = 'drop-shadow(0 0 15px rgba(255, 50, 0, 1))';
  document.body.appendChild(fallingRocket);
 
  setTimeout(() => {
    fallingRocket.style.top = targetCenterY - 20 + 'px';
  }, 100);

  // VERIFICAR SI HAY TORRE DESVIADORA
  if (deflectorTower) {
    // Esperar a que el cohete est√© a mitad de camino
    await new Promise(resolve => setTimeout(resolve, 750));
    
    // ALEATORIO: 70% desv√≠o completo, 30% desv√≠o parcial con da√±o
    const deflectionSuccess = Math.random() < 0.7;
    
    // Activar animaci√≥n de la torre
    const towerCell = $('islandGrid').querySelector(`[data-row="${deflectorTower.row}"][data-col="${deflectorTower.col}"]`);
    if (towerCell) {
      // Flash intenso de la torre (m√°s d√©bil si falla)
      const intensity = deflectionSuccess ? '0 0 30px #00CED1, 0 0 50px #00CED1, 0 0 70px #00CED1' : '0 0 15px #00CED1, 0 0 25px #00CED1';
      towerCell.style.boxShadow = intensity;
      towerCell.style.transform = 'scale(1.3)';
      towerCell.style.transition = 'all 0.3s ease';
      
      // Crear rayo de energ√≠a desde la torre al cohete
      const towerRect = towerCell.getBoundingClientRect();
      const towerCenterX = towerRect.left + towerRect.width / 2;
      const towerCenterY = towerRect.top + towerRect.height / 2;
      
      const energyBeam = document.createElement('div');
      const rocketCurrentLeft = parseFloat(fallingRocket.style.left) + 20;
      const rocketCurrentTop = parseFloat(fallingRocket.style.top) + 20;
      
      energyBeam.style.position = 'fixed';
      energyBeam.style.left = towerCenterX + 'px';
      energyBeam.style.top = towerCenterY + 'px';
      energyBeam.style.width = '5px';
      const distance = Math.sqrt(Math.pow(rocketCurrentLeft - towerCenterX, 2) + Math.pow(rocketCurrentTop - towerCenterY, 2));
      energyBeam.style.height = distance + 'px';
      // Rayo m√°s d√©bil si falla
      const beamColor = deflectionSuccess ? 'linear-gradient(to bottom, rgba(0, 255, 255, 0.9), rgba(0, 206, 209, 0.5))' : 'linear-gradient(to bottom, rgba(0, 255, 255, 0.5), rgba(0, 206, 209, 0.3))';
      energyBeam.style.background = beamColor;
      energyBeam.style.boxShadow = '0 0 20px #00CED1, 0 0 40px #00FFFF';
      energyBeam.style.zIndex = '10000';
      energyBeam.style.transformOrigin = 'top center';
      const angle = Math.atan2(rocketCurrentTop - towerCenterY, rocketCurrentLeft - towerCenterX) * (180 / Math.PI) + 90;
      energyBeam.style.transform = `rotate(${angle}deg)`;
      document.body.appendChild(energyBeam);
      
      setTimeout(() => {
        towerCell.style.boxShadow = '';
        towerCell.style.transform = '';
        if (document.body.contains(energyBeam)) energyBeam.remove();
      }, 500);
    }
    
    if (deflectionSuccess) {
      // DESV√çO COMPLETO: Cohete va al borde del mapa
      fallingRocket.style.transition = 'all 1.0s ease-out';
      
      // Determinar el borde m√°s cercano para desviar
      const viewportRect = $('islandViewport').getBoundingClientRect();
      const currentLeft = parseFloat(fallingRocket.style.left);
      const currentTop = parseFloat(fallingRocket.style.top);
      
      // Calcular distancias a cada borde
      const distToRight = viewportRect.right - currentLeft;
      const distToLeft = currentLeft - viewportRect.left;
      const distToTop = currentTop - viewportRect.top;
      const distToBottom = viewportRect.bottom - currentTop;
      
      // Encontrar el borde m√°s cercano
      const minDist = Math.min(distToRight, distToLeft, distToTop, distToBottom);
      
      let seaX, seaY;
      if (minDist === distToRight) {
        seaX = viewportRect.right - 50;
        seaY = currentTop + (Math.random() - 0.5) * 100;
      } else if (minDist === distToLeft) {
        seaX = viewportRect.left + 50;
        seaY = currentTop + (Math.random() - 0.5) * 100;
      } else if (minDist === distToTop) {
        seaX = currentLeft + (Math.random() - 0.5) * 100;
        seaY = viewportRect.top + 50;
      } else {
        seaX = currentLeft + (Math.random() - 0.5) * 100;
        seaY = viewportRect.bottom - 50;
      }
      
      fallingRocket.style.left = seaX + 'px';
      fallingRocket.style.top = seaY + 'px';
      fallingRocket.style.transform = 'rotate(45deg)';
      
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      // EXPLOSI√ìN EN EL MAR (EN EL BORDE DEL MAPA)
      fallingRocket.remove();
      
      // Reproducir sonido de explosi√≥n
      const explosionSound = $('explosionSound');
      explosionSound.currentTime = 0;
      explosionSound.volume = 0.4;
      explosionSound.play().catch(e => console.log('Error reproduciendo sonido:', e));
      
      // Efecto de temblor
      const viewport = $('islandViewport');
      viewport.classList.add('shake');
      setTimeout(() => viewport.classList.remove('shake'), 500);
      
      // Crear explosi√≥n principal (fuego + agua)
      const mainExplosion = document.createElement('div');
      mainExplosion.style.position = 'fixed';
      mainExplosion.style.left = (seaX - 30) + 'px';
      mainExplosion.style.top = (seaY - 30) + 'px';
      mainExplosion.style.fontSize = '80px';
      mainExplosion.style.zIndex = '10003';
      mainExplosion.textContent = 'üí•';
      mainExplosion.style.animation = 'splashAnimation 0.8s ease-out';
      document.body.appendChild(mainExplosion);
      
      // Crear explosi√≥n de agua
      const waterSplash = document.createElement('div');
      waterSplash.style.position = 'fixed';
      waterSplash.style.left = seaX + 'px';
      waterSplash.style.top = seaY + 'px';
      waterSplash.style.fontSize = '60px';
      waterSplash.style.zIndex = '10002';
      waterSplash.textContent = 'üí¶';
      waterSplash.style.animation = 'splashAnimation 1s ease-out';
      document.body.appendChild(waterSplash);
      
      // Crear part√≠culas de fuego (explosi√≥n)
      const colors = ['#ff4500', '#ff6347', '#ff8c00', '#ffa500', '#ffff00', '#ff0000'];
      for (let i = 0; i < 20; i++) {
        const particle = document.createElement('div');
        particle.className = 'explosion-particle';
        particle.style.left = seaX + 'px';
        particle.style.top = seaY + 'px';
        particle.style.background = colors[Math.floor(Math.random() * colors.length)];
        
        const angle = (Math.PI * 2 * i) / 20;
        const velocity = 80 + Math.random() * 100;
        const tx = Math.cos(angle) * velocity;
        const ty = Math.sin(angle) * velocity;
        
        particle.style.animation = `explode 1s ease-out forwards`;
        particle.style.transform = `translate(${tx}px, ${ty}px) scale(${Math.random() * 1.5 + 0.5})`;
        
        document.body.appendChild(particle);
        setTimeout(() => particle.remove(), 1000);
      }
      
      // Crear part√≠culas de agua
      for (let i = 0; i < 15; i++) {
        const droplet = document.createElement('div');
        droplet.style.position = 'fixed';
        droplet.style.left = seaX + 'px';
        droplet.style.top = seaY + 'px';
        droplet.style.fontSize = '24px';
        droplet.style.zIndex = '10001';
        droplet.textContent = 'üíß';
        
        const angle = (Math.PI * 2 * i) / 15;
        const distance = 50 + Math.random() * 50;
        const endX = seaX + Math.cos(angle) * distance;
        const endY = seaY + Math.sin(angle) * distance;
        
        droplet.style.transition = 'all 0.8s ease-out';
        document.body.appendChild(droplet);
        
        setTimeout(() => {
          droplet.style.left = endX + 'px';
          droplet.style.top = endY + 'px';
          droplet.style.opacity = '0';
          droplet.style.transform = 'scale(0.3)';
        }, 50);
        
        setTimeout(() => droplet.remove(), 900);
      }
      
      // Efecto de onda expansiva azul
      const shockwave = document.createElement('div');
      shockwave.style.position = 'fixed';
      shockwave.style.left = (seaX - 50) + 'px';
      shockwave.style.top = (seaY - 50) + 'px';
      shockwave.style.width = '100px';
      shockwave.style.height = '100px';
      shockwave.style.borderRadius = '50%';
      shockwave.style.border = '3px solid rgba(0, 150, 255, 0.8)';
      shockwave.style.zIndex = '10000';
      shockwave.style.transition = 'all 0.6s ease-out';
      document.body.appendChild(shockwave);
      
      setTimeout(() => {
        shockwave.style.width = '300px';
        shockwave.style.height = '300px';
        shockwave.style.left = (seaX - 150) + 'px';
        shockwave.style.top = (seaY - 150) + 'px';
        shockwave.style.opacity = '0';
      }, 50);
      
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      mainExplosion.remove();
      waterSplash.remove();
      shockwave.remove();
      
      // Mensaje de √©xito (notificaci√≥n flotante)
      showXPNotification(0, window.innerWidth / 2 - 100, window.innerHeight / 2, 'üõ°Ô∏è DESVIADO AL MAR');
      
      // RESTAURAR BOTONES DE UI
      $('backButton').style.display = 'block';
      $('inventoryButton').style.display = 'none';
      $('shopButton').style.display = 'none';
      $('attackButton').style.display = 'block';
      $('islandAchievementsButton').style.display = 'block';
      $('islandTextureToggle').style.display = 'block';
      $('islandGridToggle').style.display = 'block';
      
      // RESTAURAR INTERACCI√ìN
      islandViewport.style.pointerEvents = 'auto';
      islandWorld.style.pointerEvents = 'auto';
      
      state.attacking = false;
      state.placing = null;
      state.dragLocked = false;
      $('islandViewport').style.cursor = 'grab';
      await set(ref(db, `villages/${attackTarget.id}/underAttack`), false);
      await set(ref(db, `villages/${attackTarget.id}/currentAttack`), { active: false });
      loading(false);
      return;
    } else {
      // DESV√çO PARCIAL: Cohete desviado pero cae cerca del mapa (da√±o reducido 3x3)
      fallingRocket.style.transition = 'all 0.8s ease-out';
      
      // Desviar ligeramente del objetivo original (2-4 celdas de distancia)
      const offsetRow = attackTarget.row + Math.floor((Math.random() - 0.5) * 6);
      const offsetCol = attackTarget.col + Math.floor((Math.random() - 0.5) * 6);
      const clampedRow = Math.max(0, Math.min(19, offsetRow));
      const clampedCol = Math.max(0, Math.min(19, offsetCol));
      
      const deflectedCell = $('islandGrid').querySelector(`[data-row="${clampedRow}"][data-col="${clampedCol}"]`);
      if (deflectedCell) {
        const deflectedRect = deflectedCell.getBoundingClientRect();
        fallingRocket.style.left = (deflectedRect.left + deflectedRect.width / 2 - 20) + 'px';
        fallingRocket.style.top = (deflectedRect.top + deflectedRect.height / 2 - 20) + 'px';
      }
      
      await new Promise(resolve => setTimeout(resolve, 800));
      
      fallingRocket.remove();
      
      // Efecto de temblor (m√°s suave)
      const viewport = $('islandViewport');
      viewport.classList.add('shake');
      setTimeout(() => viewport.classList.remove('shake'), 300);
      
      // Explosi√≥n en la isla
      const finalCell = $('islandGrid').querySelector(`[data-row="${clampedRow}"][data-col="${clampedCol}"]`);
      if (finalCell) {
        const finalRect = finalCell.getBoundingClientRect();
        const explosionX = finalRect.left + finalRect.width / 2;
        const explosionY = finalRect.top + finalRect.height / 2;
        createExplosion(explosionX, explosionY);
      }
      
      // Aplicar da√±o REDUCIDO (3x3 en lugar de 7x7)
      let damagedCells = 0;
      for (let dx = -1; dx <= 1; dx++) {
        for (let dy = -1; dy <= 1; dy++) {
          const nr = clampedRow + dx, nc = clampedCol + dy;
          if (nr >= 0 && nr < 20 && nc >= 0 && nc < 20 && !(nr === 10 && nc === 10)) {
            // Verificar si hay alguna estructura en esta posici√≥n
            const hasMine = state.buildings.mines.some(m => m.row === nr && m.col === nc);
            const hasRocket = state.buildings.rocketLaunchers.some(rl => rl.row === nr && rl.col === nc);
            const hasAATurret = state.buildings.aaTurrets.some(aa => aa.row === nr && aa.col === nc);
            const hasDeflector = state.buildings.deflectorTowers.some(dt => dt.row === nr && dt.col === nc);
            const hasStatue = state.buildings.statues.some(s => s.row === nr && s.col === nc);
            const hasFlower = state.buildings.flowers.some(f => f.row === nr && f.col === nc);
            const alreadyDamaged = state.buildings.damaged.some(d => d.row === nr && d.col === nc);
            
            if (!hasMine && !hasRocket && !hasAATurret && !hasDeflector && !hasStatue && !hasFlower && !alreadyDamaged) {
              const target = $('islandGrid').querySelector(`[data-row="${nr}"][data-col="${nc}"]`);
              if (target) {
                state.buildings.damaged.push({row: nr, col: nc});
                target.classList.add('damaged');
                damagedCells++;
              }
            }
          }
        }
      }
      
      await set(ref(db, `users/${attackTarget.owner}/buildings`), {
        goldMines: state.buildings.mines,
        rocketLaunchers: state.buildings.rocketLaunchers,
        superRocketLaunchers: state.buildings.superRocketLaunchers,
        aaTurrets: state.buildings.aaTurrets,
        deflectorTowers: state.buildings.deflectorTowers,
        statues: state.buildings.statues,
        flowers: state.buildings.flowers,
        damaged: state.buildings.damaged
      });
      
      // Dar XP reducido al atacante
      const attackerLevelSnap = await get(ref(db, `users/${state.user}/level`));
      if (attackerLevelSnap.exists()) {
        let attackerLevel = attackerLevelSnap.val();
        attackerLevel.xp = (attackerLevel.xp || 0) + 15; // Menos XP que un ataque completo
        
        while (attackerLevel.xp >= attackerLevel.needed && attackerLevel.level < 20) {
          attackerLevel.xp -= attackerLevel.needed;
          attackerLevel.level++;
          attackerLevel.needed = attackerLevel.level * 100;
        }
        
        if (attackerLevel.level >= 20) attackerLevel.xp = Math.min(attackerLevel.xp, attackerLevel.needed - 1);
        
        await set(ref(db, `users/${state.user}/level`), attackerLevel);
      }
      
      // RESTAURAR BOTONES DE UI
      $('backButton').style.display = 'block';
      $('inventoryButton').style.display = 'none';
      $('shopButton').style.display = 'none';
      $('attackButton').style.display = 'block';
      $('islandAchievementsButton').style.display = 'block';
      $('islandTextureToggle').style.display = 'block';
      $('islandGridToggle').style.display = 'block';
      
      // RESTAURAR INTERACCI√ìN
      islandViewport.style.pointerEvents = 'auto';
      islandWorld.style.pointerEvents = 'auto';
      
      state.attacking = false;
      state.placing = null;
      state.dragLocked = false;
      $('islandViewport').style.cursor = 'grab';
      await set(ref(db, `villages/${attackTarget.id}/underAttack`), false);
      await set(ref(db, `villages/${attackTarget.id}/currentAttack`), { active: false });
      
      // Mostrar notificaci√≥n de XP reducido
      showXPNotification(15, window.innerWidth / 2 - 50, window.innerHeight / 2);
      
      loading(false);
      return;
    }
  }

  // Paso 6: EXPLOSI√ìN con efectos (solo si NO fue desviado)
  await new Promise(resolve => setTimeout(resolve, 750));

  // GRABAR EXPLOSI√ìN
  recordAction('explosion', { 
    targetRow: attackTarget.row, 
    targetCol: attackTarget.col 
  }, 1600);

  fallingRocket.remove();
 
  // Obtener posici√≥n final para la explosi√≥n
  const finalTargetCell = $('islandGrid').querySelector(`[data-row="${attackTarget.row}"][data-col="${attackTarget.col}"]`);
  const finalTargetRect = finalTargetCell.getBoundingClientRect();
  const explosionX = finalTargetRect.left + finalTargetRect.width / 2;
  const explosionY = finalTargetRect.top + finalTargetRect.height / 2;
 
  // Efecto de temblor
  const viewport = $('islandViewport');
  viewport.classList.add('shake');
  setTimeout(() => viewport.classList.remove('shake'), 500);
 
  // Crear part√≠culas de explosi√≥n
  createExplosion(explosionX, explosionY);
 
  // Aplicar da√±o (7x7)
  let castleHit = false;
  
  for (let dx = -3; dx <= 3; dx++) {
    for (let dy = -3; dy <= 3; dy++) {
      const nr = attackTarget.row + dx, nc = attackTarget.col + dy;
      if (nr >= 0 && nr < 20 && nc >= 0 && nc < 20) {
        // Verificar si impact√≥ el castillo
        if (nr === 10 && nc === 10) {
          castleHit = true;
          continue;
        }
        
        // Verificar si hay alguna estructura en esta posici√≥n
        const hasMine = state.buildings.mines.some(m => m.row === nr && m.col === nc);
        const hasRocket = state.buildings.rocketLaunchers.some(rl => rl.row === nr && rl.col === nc);
        const aaTurret = state.buildings.aaTurrets.find(aa => aa.row === nr && aa.col === nc);
        const deflector = state.buildings.deflectorTowers.find(dt => dt.row === nr && dt.col === nc);
        const hasStatue = state.buildings.statues.some(s => s.row === nr && s.col === nc);
        const hasFlower = state.buildings.flowers.some(f => f.row === nr && f.col === nc);
        const alreadyDamaged = state.buildings.damaged.some(d => d.row === nr && d.col === nc);
        
        // Da√±ar Torre Anti-A√©rea
        if (aaTurret) {
          aaTurret.health = (aaTurret.health !== undefined ? aaTurret.health : 150) - 50;
          if (aaTurret.health <= 0) {
            aaTurret.health = 0;
            aaTurret.destroyed = true;
          }
        }
        // Da√±ar Torre Desviadora
        else if (deflector) {
          deflector.health = (deflector.health !== undefined ? deflector.health : 150) - 50;
          if (deflector.health <= 0) {
            deflector.health = 0;
            deflector.destroyed = true;
          }
        }
        // Da√±ar terreno
        else if (!hasMine && !hasRocket && !hasStatue && !hasFlower && !alreadyDamaged) {
          const target = $('islandGrid').querySelector(`[data-row="${nr}"][data-col="${nc}"]`);
          if (target) {
            state.buildings.damaged.push({row: nr, col: nc});
            target.classList.add('damaged');
          }
        }
      }
    }
  }
  
  // Si el castillo fue impactado, reducir su salud
  if (castleHit) {
    const villageRef = ref(db, `villages/${attackTarget.id}`);
    const villageSnap = await get(villageRef);
    if (villageSnap.exists()) {
      const villageData = villageSnap.val();
      let castleHealth = villageData.castleHealth !== undefined ? villageData.castleHealth : 500;
      const maxHealth = villageData.castleMaxHealth || 500;
      castleHealth = Math.max(0, castleHealth - 50); // Bomba hace 50 de da√±o
      
      await set(villageRef, {
        ...villageData,
        castleHealth: castleHealth
      });
      
      state.currentVillage.castleHealth = castleHealth;
      
      // Actualizar barra de vida
      updateCastleHealthBar();
      
      // Actualizar visual del castillo
      const castleCell = $('islandGrid').querySelector(`[data-row="10"][data-col="10"]`);
      if (castleCell) {
        if (castleHealth <= 0) {
          castleCell.textContent = 'üï≥Ô∏è';
          castleCell.classList.remove('my-castle', 'enemy-castle');
          castleCell.classList.add('destroyed-castle');
          // Remover barra de vida
          const healthBar = castleCell.querySelector('.health-bar-container');
          const healthText = castleCell.querySelector('.health-text');
          if (healthBar) healthBar.remove();
          if (healthText) healthText.remove();
          showXPNotification(0, window.innerWidth / 2 - 100, window.innerHeight / 2, 'üí• ¬°CASTILLO DESTRUIDO!');
        } else {
          showXPNotification(0, window.innerWidth / 2 - 100, window.innerHeight / 2, `üí£ -50 HP | ${castleHealth}/${maxHealth}`);
        }
      }
    }
  }
 
  await set(ref(db, `users/${attackTarget.owner}/buildings`), {
    goldMines: state.buildings.mines,
    rocketLaunchers: state.buildings.rocketLaunchers,
    superRocketLaunchers: state.buildings.superRocketLaunchers,
    aaTurrets: state.buildings.aaTurrets,
    deflectorTowers: state.buildings.deflectorTowers,
    statues: state.buildings.statues,
    flowers: state.buildings.flowers,
    damaged: state.buildings.damaged
  });
  
  // Actualizar visual de torres (destruidas o da√±adas)
  updateTowerHealthVisuals();
 
  // Dar XP al atacante (state.user), no al due√±o de la aldea
  const attackerLevelSnap = await get(ref(db, `users/${state.user}/level`));
  if (attackerLevelSnap.exists()) {
    let attackerLevel = attackerLevelSnap.val();
    attackerLevel.xp = (attackerLevel.xp || 0) + 50;
    
    // Verificar si sube de nivel
    while (attackerLevel.xp >= attackerLevel.needed && attackerLevel.level < 20) {
      attackerLevel.xp -= attackerLevel.needed;
      attackerLevel.level++;
      attackerLevel.needed = attackerLevel.level * 100;
    }
    
    if (attackerLevel.level >= 20) attackerLevel.xp = Math.min(attackerLevel.xp, attackerLevel.needed - 1);
    
    await set(ref(db, `users/${state.user}/level`), attackerLevel);
  }
  
  // RESTAURAR BOTONES DE UI
  $('backButton').style.display = 'block';
  $('inventoryButton').style.display = 'none';
  $('shopButton').style.display = 'none';
  $('attackButton').style.display = 'block';
  $('islandAchievementsButton').style.display = 'block';
  $('islandTextureToggle').style.display = 'block';
  $('islandGridToggle').style.display = 'block';
  
  state.attacking = false;
  state.placing = null;
  state.dragLocked = false;
  $('islandViewport').style.cursor = 'grab';
  await set(ref(db, `villages/${attackTarget.id}/underAttack`), false);
  
  // GUARDAR ACCIONES PARA ESPECTADORES CON DELAY DE 1 SEGUNDO
  setTimeout(async () => {
    await set(ref(db, `villages/${attackTarget.id}/currentAttack`), {
      active: true,
      actions: attackActions,
      timestamp: Date.now()
    });
    
    // Limpiar despu√©s de que termine la animaci√≥n (aproximadamente 10 segundos)
    setTimeout(async () => {
      await set(ref(db, `villages/${attackTarget.id}/currentAttack`), { active: false });
    }, 10000);
  }, 1000);
 
  setTimeout(() => {
    // Mostrar notificaci√≥n de XP en el centro
    showXPNotification(50, window.innerWidth / 2 - 50, window.innerHeight / 2);
    loading(false);
  }, 1000);
}
async function launchSuperRocketAttack(r, c) {
  // Prevenir m√∫ltiples clicks
  if (state.dragLocked) return;
  
  // Bloquear movimiento del mapa y m√°s clicks
  state.dragLocked = true;
  $('islandViewport').style.cursor = 'default';
  
  // Verificar si hay un bombardero activo
  if (state.bomberActive) {
    alert('¬°Espera a que termine el bombardeo antes de lanzar un super cohete!');
    state.attacking = false;
    state.placing = null;
    state.dragLocked = false;
    $('islandViewport').style.cursor = 'grab';
    await set(ref(db, `villages/${state.currentVillage.id}/underAttack`), false);
    return;
  }
  
  // Verificar si el usuario tiene munici√≥n de super cohetes
  const superRocketAmmoSnap = await get(ref(db, `users/${state.user}/inventory/superRocketAmmo`));
  const superRocketAmmo = superRocketAmmoSnap.exists() ? superRocketAmmoSnap.val() : 0;
  
  if (superRocketAmmo <= 0) {
    alert('¬°Necesitas munici√≥n de SUPER COHETES! C√≥mprala en la tienda global.');
    state.attacking = false;
    state.placing = null;
    state.dragLocked = false;
    $('islandViewport').style.cursor = 'grab';
    await set(ref(db, `villages/${state.currentVillage.id}/underAttack`), false);
    return;
  }
  
  // Restar una munici√≥n
  await set(ref(db, `users/${state.user}/inventory/superRocketAmmo`), superRocketAmmo - 1);

  // SISTEMA DE GRABACI√ìN PARA ESPECTADORES
  const attackActions = [];
  const recordAction = (type, data, delay = 0) => {
    attackActions.push({ type, ...data, delay });
  };

  // Guardar datos del ataque y zoom actual
  const attackTarget = {row: r, col: c, owner: state.currentVillage.owner, id: state.currentVillage.id};
  const savedZoom = {
    x: state.view.island.x,
    y: state.view.island.y,
    scale: state.view.island.scale
  };
 
  // Obtener datos de mi aldea para el SUPER lanza cohetes
  const myBuildingsSnap = await get(ref(db, `users/${state.user}/buildings`));
  const myBuildings = myBuildingsSnap.exists() ? myBuildingsSnap.val() : {};
  const mySuperRocketLaunchers = myBuildings.superRocketLaunchers || [];
 
  if (mySuperRocketLaunchers.length === 0) {
    alert('¬°Necesitas construir un SUPER LANZADOR en tu aldea primero!');
    state.attacking = false;
    state.placing = null;
    state.dragLocked = false;
    $('islandViewport').style.cursor = 'grab';
    await set(ref(db, `villages/${attackTarget.id}/underAttack`), false);
    return;
  }
 
  const mySuperRocketLauncher = mySuperRocketLaunchers[0];

  // Paso 1: Transici√≥n a mi aldea
  recordAction('transition_attacker', { attacker: state.user }, 0);
  
  $('fade').style.opacity = 1;
  await new Promise(resolve => setTimeout(resolve, 400));

  state.skipCentering = true;
  await openIsland(state.user);

  // OCULTAR BOTONES DE UI DURANTE LA ANIMACI√ìN
  $('backButton').style.display = 'none';
  $('inventoryButton').style.display = 'none';
  $('shopButton').style.display = 'none';
  $('marketButton').style.display = 'none';
  $('islandAchievementsButton').style.display = 'none';
  $('islandTextureToggle').style.display = 'none';
  $('islandGridToggle').style.display = 'none';

  // Centrar en el super lanza cohetes sin animaci√≥n
  const superRocketLauncherCell = $('islandGrid').querySelector(`[data-row="${mySuperRocketLauncher.row}"][data-col="${mySuperRocketLauncher.col}"]`);
  if (!superRocketLauncherCell) {
    alert('Error: No se pudo encontrar el super lanzador');
    // RESTAURAR BOTONES DE UI en caso de error
    $('backButton').style.display = 'block';
    $('inventoryButton').style.display = state.user === state.currentVillage.owner ? 'block' : 'none';
    $('shopButton').style.display = state.user === state.currentVillage.owner ? 'block' : 'none';
    $('marketButton').style.display = state.user === state.currentVillage.owner ? 'block' : 'none';
    $('attackButton').style.display = state.user !== state.currentVillage.owner ? 'block' : 'none';
    $('islandAchievementsButton').style.display = 'block';
    $('islandTextureToggle').style.display = 'block';
    $('islandGridToggle').style.display = 'block';
    return;
  }
 
  const gridPadding = 200;
  const cellSize = 40;
  const gap = 2;
  const rocketWorldX = gridPadding + mySuperRocketLauncher.col * (cellSize + gap) + cellSize / 2;
  const rocketWorldY = gridPadding + mySuperRocketLauncher.row * (cellSize + gap) + cellSize / 2;
 
  const viewportRect = $('islandViewport').getBoundingClientRect();
  const centerX = viewportRect.width / 2;
  const centerY = viewportRect.height / 2;
 
  const currentScale = state.view.island.scale;
  state.view.island.x = centerX - rocketWorldX * currentScale;
  state.view.island.y = centerY - rocketWorldY * currentScale;
  $('islandWorld').style.transition = '';
  updateTransform('island');
 
  setTimeout(() => $('fade').style.opacity = 0, 100);
 
  // Paso 3: Lanzar SUPER cohete hacia arriba con SHAKE CONTINUO
  await new Promise(resolve => setTimeout(resolve, 500));
  
  // GRABAR LANZAMIENTO DEL SUPER COHETE
  recordAction('super_rocket_launch', { 
    launcherRow: mySuperRocketLauncher.row, 
    launcherCol: mySuperRocketLauncher.col 
  }, 500);

  // Obtener la posici√≥n actualizada del super lanzador
  const updatedSuperRocketLauncherCell = $('islandGrid').querySelector(`[data-row="${mySuperRocketLauncher.row}"][data-col="${mySuperRocketLauncher.col}"]`);
  const updatedRect = updatedSuperRocketLauncherCell.getBoundingClientRect();

  // Reproducir sonido de lanzamiento (reutilizar el del cohete normal)
  const rocketSound = $('rocketSound');
  rocketSound.currentTime = 0;
  rocketSound.volume = 0.7; // M√°s fuerte que el normal
  rocketSound.play().catch(e => console.log('Error reproduciendo sonido:', e));
  
  const rocket = document.createElement('div');
  rocket.style.position = 'fixed';
  rocket.style.fontSize = '50px'; // M√°s grande que el cohete normal
  rocket.style.left = updatedRect.left + updatedRect.width / 2 - 25 + 'px';
  rocket.style.top = updatedRect.top + updatedRect.height / 2 - 25 + 'px';
  rocket.style.zIndex = '10001';
  rocket.textContent = 'üí•';
  rocket.style.filter = 'drop-shadow(0 0 15px rgba(255, 50, 0, 1))';
  document.body.appendChild(rocket);

  // SHAKE CONTINUO durante el despegue
  const viewport = $('islandViewport');
  let shakeInterval = setInterval(() => {
    viewport.style.transform = `translate(${Math.random() * 10 - 5}px, ${Math.random() * 10 - 5}px)`;
  }, 50);

  // Variables para rastrear la posici√≥n del cohete
  const rocketStartTime = Date.now();
  const rocketDuration = 3500;
  const rocketStartY = parseFloat(rocket.style.top);
  const rocketStartX = parseFloat(rocket.style.left);
  const rocketEndY = rocketStartY - 1200;

  // Crear part√≠culas de humo MASIVAS
  const smokeInterval = setInterval(() => {
    const elapsed = Date.now() - rocketStartTime;
    const progress = Math.min(elapsed / rocketDuration, 1);
    const easeProgress = progress * progress;
    
    const currentRocketY = rocketStartY - (easeProgress * (rocketStartY - rocketEndY));
    
    // MUCHAS m√°s part√≠culas por intervalo
    for (let i = 0; i < 12; i++) {
      const smoke = document.createElement('div');
      smoke.style.position = 'fixed';
      
      smoke.style.left = (rocketStartX + 25 + (Math.random() - 0.5) * 30) + 'px';
      smoke.style.top = (currentRocketY + 40) + 'px';
      
      smoke.style.width = (15 + Math.random() * 25) + 'px';
      smoke.style.height = (15 + Math.random() * 25) + 'px';
      smoke.style.borderRadius = '50%';
      
      const opacity = 0.7 + Math.random() * 0.3;
      const gray = 150 + Math.random() * 75;
      smoke.style.backgroundColor = `rgba(${gray}, ${gray}, ${gray}, ${opacity})`;
      smoke.style.zIndex = '10000';
      smoke.style.pointerEvents = 'none';
      
      document.body.appendChild(smoke);
      
      setTimeout(() => {
        smoke.style.transition = 'all 1.2s ease-out';
        smoke.style.opacity = '0';
        smoke.style.transform = `translate(${(Math.random() - 0.5) * 70}px, ${Math.random() * 50}px) scale(2)`;
      }, 50);
      
      setTimeout(() => smoke.remove(), 1300);
    }
    
    if (progress >= 1) {
      clearInterval(smokeInterval);
    }
  }, 60);

  // Animar el cohete subiendo
  rocket.style.transition = `top ${rocketDuration}ms ease-in`;
  rocket.style.top = rocketEndY + 'px';

  await new Promise(resolve => setTimeout(resolve, rocketDuration));
  
  // Detener el shake continuo
  clearInterval(shakeInterval);
  viewport.style.transform = '';
  clearInterval(smokeInterval);
  rocket.remove();

  // ‚ö†Ô∏è DA√ëO COLATERAL EN LA ALDEA DEL ATACANTE (5 bloques alrededor del lanzador)
  let collateralDamage = 0;
  const launcherRow = mySuperRocketLauncher.row;
  const launcherCol = mySuperRocketLauncher.col;
  
  for (let dx = -2; dx <= 2; dx++) {
    for (let dy = -2; dy <= 2; dy++) {
      const nr = launcherRow + dx;
      const nc = launcherCol + dy;
      
      // No da√±ar el lanzador mismo ni el castillo
      if ((dx === 0 && dy === 0) || (nr === 10 && nc === 10)) continue;
      
      if (nr >= 0 && nr < 20 && nc >= 0 && nc < 20) {
        const hasMine = state.buildings.mines.some(m => m.row === nr && m.col === nc);
        const hasRocket = state.buildings.rocketLaunchers.some(rl => rl.row === nr && rl.col === nc);
        const hasSuperRocket = state.buildings.superRocketLaunchers.some(sr => sr.row === nr && sr.col === nc);
        const hasAATurret = state.buildings.aaTurrets.some(aa => aa.row === nr && aa.col === nc);
        const hasDeflector = state.buildings.deflectorTowers.some(dt => dt.row === nr && dt.col === nc);
        const hasStatue = state.buildings.statues.some(s => s.row === nr && s.col === nc);
        const hasFlower = state.buildings.flowers.some(f => f.row === nr && f.col === nc);
        const alreadyDamaged = state.buildings.damaged.some(d => d.row === nr && d.col === nc);
        
        if (!hasMine && !hasRocket && !hasSuperRocket && !hasAATurret && !hasDeflector && !hasStatue && !hasFlower && !alreadyDamaged) {
          const target = $('islandGrid').querySelector(`[data-row="${nr}"][data-col="${nc}"]`);
          if (target) {
            state.buildings.damaged.push({row: nr, col: nc});
            target.classList.add('damaged');
            collateralDamage++;
          }
        }
      }
    }
  }
  
  // Guardar el da√±o colateral
  if (collateralDamage > 0) {
    await set(ref(db, `users/${state.user}/buildings`), {
      goldMines: state.buildings.mines,
      rocketLaunchers: state.buildings.rocketLaunchers,
      superRocketLaunchers: state.buildings.superRocketLaunchers,
      aaTurrets: state.buildings.aaTurrets,
      deflectorTowers: state.buildings.deflectorTowers,
      statues: state.buildings.statues,
      flowers: state.buildings.flowers,
      damaged: state.buildings.damaged
    });
    
    // Mostrar notificaci√≥n de da√±o colateral
    showXPNotification(0, window.innerWidth / 2 - 100, window.innerHeight / 2 - 100, `‚ö†Ô∏è ${collateralDamage} bloques da√±ados en tu aldea`);
  }

  // Paso 4: Transici√≥n a la aldea atacada
  recordAction('transition_target', { target: attackTarget.owner }, 3500);
  
  $('fade').style.opacity = 1;
  await new Promise(resolve => setTimeout(resolve, 400));

  // Cargar aldea objetivo desde Firebase
  state.skipCentering = true;
  await openIsland(attackTarget.owner);
  state.currentVillage.id = attackTarget.id;

  // Restaurar el zoom que ten√≠a el usuario
  $('islandWorld').style.transition = '';
  state.view.island.x = savedZoom.x;
  state.view.island.y = savedZoom.y;
  state.view.island.scale = savedZoom.scale;
  updateTransform('island');

  // Forzar que los botones aparezcan inmediatamente
  $('backButton').style.display = 'block';
  $('islandAchievementsButton').style.display = 'block';
  $('islandTextureToggle').style.display = 'block';
  $('islandGridToggle').style.display = 'block';

  setTimeout(() => $('fade').style.opacity = 0, 100);

  // Paso 5: SUPER Cohete cae desde arriba
  await new Promise(resolve => setTimeout(resolve, 800));
  
  // GRABAR CA√çDA DEL SUPER COHETE
  recordAction('super_rocket_fall', { 
    targetRow: attackTarget.row, 
    targetCol: attackTarget.col 
  }, 800);

  // Calcular la posici√≥n exacta de la celda objetivo
  const targetCell = $('islandGrid').querySelector(`[data-row="${attackTarget.row}"][data-col="${attackTarget.col}"]`);
  if (!targetCell) {
    alert('Error: No se pudo encontrar la celda objetivo');
    // RESTAURAR BOTONES DE UI en caso de error
    $('backButton').style.display = 'block';
    $('inventoryButton').style.display = 'none';
    $('shopButton').style.display = 'none';
    $('attackButton').style.display = 'block';
    $('islandAchievementsButton').style.display = 'block';
    $('islandTextureToggle').style.display = 'block';
    $('islandGridToggle').style.display = 'block';
    return;
  }

  const targetRect = targetCell.getBoundingClientRect();
  const targetCenterX = targetRect.left + targetRect.width / 2;
  const targetCenterY = targetRect.top + targetRect.height / 2;

  const fallingRocket = document.createElement('div');
  fallingRocket.style.position = 'fixed';
  fallingRocket.style.fontSize = '50px';
  fallingRocket.style.left = targetCenterX - 25 + 'px';
  fallingRocket.style.top = '-100px';
  fallingRocket.style.zIndex = '10001';
  fallingRocket.textContent = 'üí•';
  fallingRocket.style.transform = 'rotate(180deg)';
  fallingRocket.style.transition = 'top 1.5s ease-in';
  fallingRocket.style.filter = 'drop-shadow(0 0 15px rgba(255, 50, 0, 1))';
  document.body.appendChild(fallingRocket);

  setTimeout(() => {
    fallingRocket.style.top = targetCenterY - 25 + 'px';
  }, 50);

  await new Promise(resolve => setTimeout(resolve, 1500));

  fallingRocket.remove();

  // Reproducir sonido de explosi√≥n (reutilizar)
  const explosionSound = $('explosionSound');
  explosionSound.currentTime = 0;
  explosionSound.volume = 0.6;
  explosionSound.play().catch(e => console.log('Error reproduciendo sonido:', e));

  // EFECTO DE PANTALLA BLANCA (2 SEGUNDOS)
  $('fade').style.backgroundColor = 'white';
  $('fade').style.opacity = 0.95;
  setTimeout(() => {
    $('fade').style.opacity = 0;
    setTimeout(() => {
      $('fade').style.backgroundColor = 'black';
    }, 1500);
  }, 2000);

  // SHAKE ULTRA PROLONGADO (5500ms)
  viewport.classList.add('shake');
  setTimeout(() => viewport.classList.remove('shake'), 5500);

  // Crear part√≠culas de explosi√≥n masivas
  const explosionX = targetRect.left + targetRect.width / 2;
  const explosionY = targetRect.top + targetRect.height / 2;
  
  // Explosi√≥n CATASTR√ìFICA
  for (let i = 0; i < 350; i++) {
    const particle = document.createElement('div');
    particle.style.position = 'fixed';
    particle.style.left = explosionX + 'px';
    particle.style.top = explosionY + 'px';
    particle.style.width = (25 + Math.random() * 50) + 'px';
    particle.style.height = particle.style.width;
    particle.style.borderRadius = '50%';
    particle.style.backgroundColor = ['#ff4500', '#ff6347', '#ffa500', '#ffff00', '#ff0000'][Math.floor(Math.random() * 5)];
    particle.style.zIndex = '10002';
    particle.style.pointerEvents = 'none';
    document.body.appendChild(particle);
    
    const angle = Math.random() * Math.PI * 2;
    const distance = 200 + Math.random() * 500;
    const tx = Math.cos(angle) * distance;
    const ty = Math.sin(angle) * distance;
    
    setTimeout(() => {
      particle.style.transition = 'all 4.5s ease-out';
      particle.style.transform = `translate(${tx}px, ${ty}px)`;
      particle.style.opacity = '0';
    }, 50);
    
    setTimeout(() => particle.remove(), 4600);
  }

  // Aplicar da√±o MASIVO (15x15)
  let castleHit = false;
  
  for (let dx = -7; dx <= 7; dx++) {
    for (let dy = -7; dy <= 7; dy++) {
      const nr = attackTarget.row + dx;
      const nc = attackTarget.col + dy;
      if (nr >= 0 && nr < 20 && nc >= 0 && nc < 20) {
        // Verificar si impact√≥ el castillo
        if (nr === 10 && nc === 10) {
          castleHit = true;
          continue;
        }
        
        const hasMine = state.buildings.mines.some(m => m.row === nr && m.col === nc);
        const hasRocket = state.buildings.rocketLaunchers.some(rl => rl.row === nr && rl.col === nc);
        const hasSuperRocket = state.buildings.superRocketLaunchers.some(sr => sr.row === nr && sr.col === nc);
        const aaTurret = state.buildings.aaTurrets.find(aa => aa.row === nr && aa.col === nc);
        const deflector = state.buildings.deflectorTowers.find(dt => dt.row === nr && dt.col === nc);
        const hasStatue = state.buildings.statues.some(s => s.row === nr && s.col === nc);
        const hasFlower = state.buildings.flowers.some(f => f.row === nr && f.col === nc);
        const alreadyDamaged = state.buildings.damaged.some(d => d.row === nr && d.col === nc);
        
        // Da√±ar Torre Anti-A√©rea
        if (aaTurret) {
          aaTurret.health = (aaTurret.health !== undefined ? aaTurret.health : 150) - 450;
          if (aaTurret.health <= 0) {
            aaTurret.health = 0;
            aaTurret.destroyed = true;
          }
        }
        // Da√±ar Torre Desviadora
        else if (deflector) {
          deflector.health = (deflector.health !== undefined ? deflector.health : 150) - 450;
          if (deflector.health <= 0) {
            deflector.health = 0;
            deflector.destroyed = true;
          }
        }
        // Da√±ar terreno
        else if (!hasMine && !hasRocket && !hasSuperRocket && !hasStatue && !hasFlower && !alreadyDamaged) {
          const target = $('islandGrid').querySelector(`[data-row="${nr}"][data-col="${nc}"]`);
          if (target) {
            state.buildings.damaged.push({row: nr, col: nc});
            target.classList.add('damaged');
            
            // Iniciar part√≠culas de fuego continuas en el bloque
            const fireId = `fire_${nr}_${nc}`;
            if (!state.intervals.particles[fireId]) {
              state.intervals.particles[fireId] = setInterval(() => {
                const p = document.createElement('div');
                p.className = 'particula';
                p.style.left = Math.random() * target.offsetWidth + 'px';
                p.style.top = Math.random() * target.offsetHeight + 'px';
                const red = 200 + Math.random() * 55;
                const orange = Math.random() * 100;
                p.style.background = `rgb(${red}, ${orange}, 0)`;
                target.appendChild(p);
                p.onanimationend = () => p.remove();
              }, 80);
            }
          }
        }
      }
    }
  }
  
  // Si el castillo fue impactado, reducir su salud
  if (castleHit) {
    const villageRef = ref(db, `villages/${attackTarget.id}`);
    const villageSnap = await get(villageRef);
    if (villageSnap.exists()) {
      const villageData = villageSnap.val();
      let castleHealth = villageData.castleHealth !== undefined ? villageData.castleHealth : 500;
      const maxHealth = villageData.castleMaxHealth || 500;
      castleHealth = Math.max(0, castleHealth - 450); // Super Cohete hace 450 de da√±o
      
      await set(villageRef, {
        ...villageData,
        castleHealth: castleHealth
      });
      
      state.currentVillage.castleHealth = castleHealth;
      
      // Actualizar barra de vida
      updateCastleHealthBar();
      
      // Actualizar visual del castillo
      const castleCell = $('islandGrid').querySelector(`[data-row="10"][data-col="10"]`);
      if (castleCell) {
        if (castleHealth <= 0) {
          castleCell.textContent = 'üï≥Ô∏è';
          castleCell.classList.remove('my-castle', 'enemy-castle');
          castleCell.classList.add('destroyed-castle');
          // Remover barra de vida
          const healthBar = castleCell.querySelector('.health-bar-container');
          const healthText = castleCell.querySelector('.health-text');
          if (healthBar) healthBar.remove();
          if (healthText) healthText.remove();
          showXPNotification(0, window.innerWidth / 2 - 100, window.innerHeight / 2, 'üí• ¬°CASTILLO DESTRUIDO!');
        } else {
          showXPNotification(0, window.innerWidth / 2 - 100, window.innerHeight / 2, `üí• -450 HP | ${castleHealth}/${maxHealth}`);
        }
      }
    }
  }

  await set(ref(db, `users/${attackTarget.owner}/buildings`), {
    goldMines: state.buildings.mines,
    rocketLaunchers: state.buildings.rocketLaunchers,
    superRocketLaunchers: state.buildings.superRocketLaunchers,
    aaTurrets: state.buildings.aaTurrets,
    deflectorTowers: state.buildings.deflectorTowers,
    statues: state.buildings.statues,
    flowers: state.buildings.flowers,
    damaged: state.buildings.damaged
  });
  
  // Actualizar visual de torres (destruidas o da√±adas)
  updateTowerHealthVisuals();

  // Dar XP masivo al atacante
  const attackerLevelSnap = await get(ref(db, `users/${state.user}/level`));
  if (attackerLevelSnap.exists()) {
    let attackerLevel = attackerLevelSnap.val();
    attackerLevel.xp = (attackerLevel.xp || 0) + 100; // Mucho m√°s XP
    
    while (attackerLevel.xp >= attackerLevel.needed && attackerLevel.level < 20) {
      attackerLevel.xp -= attackerLevel.needed;
      attackerLevel.level++;
      attackerLevel.needed = attackerLevel.level * 100;
    }
    
    if (attackerLevel.level >= 20) attackerLevel.xp = Math.min(attackerLevel.xp, attackerLevel.needed - 1);
    
    await set(ref(db, `users/${state.user}/level`), attackerLevel);
  }
  
  // RESTAURAR BOTONES DE UI
  $('backButton').style.display = 'block';
  $('inventoryButton').style.display = 'none';
  $('shopButton').style.display = 'none';
  $('attackButton').style.display = 'block';
  $('islandAchievementsButton').style.display = 'block';
  $('islandTextureToggle').style.display = 'block';
  $('islandGridToggle').style.display = 'block';
  
  state.attacking = false;
  state.placing = null;
  state.dragLocked = false;
  $('islandViewport').style.cursor = 'grab';
  await set(ref(db, `villages/${attackTarget.id}/underAttack`), false);
  
  // GUARDAR ACCIONES PARA ESPECTADORES
  setTimeout(async () => {
    await set(ref(db, `villages/${attackTarget.id}/currentAttack`), {
      active: true,
      actions: attackActions,
      timestamp: Date.now()
    });
    
    setTimeout(async () => {
      await set(ref(db, `villages/${attackTarget.id}/currentAttack`), { active: false });
    }, 15000);
  }, 1000);
  
  showXPNotification(100, window.innerWidth / 2 - 50, window.innerHeight / 2, 'üí• DEVASTACI√ìN TOTAL');
}
async function launchBomberAttack(r, c) {
  // Prevenir m√∫ltiples clicks
  if (state.dragLocked) return;
  
  // Bloquear movimiento del mapa y m√°s clicks
  state.dragLocked = true;
  $('islandViewport').style.cursor = 'default';
  
  // Verificar si el usuario tiene aviones bombarderos
  const bomberSnap = await get(ref(db, `users/${state.user}/inventory/bomberPlanes`));
  const bomberCount = bomberSnap.exists() ? bomberSnap.val() : 0;
  
  if (bomberCount <= 0) {
    alert('¬°Necesitas un Avi√≥n Bombardero! C√≥mpralo en la tienda global.');
    state.attacking = false;
    state.placing = null;
    state.dragLocked = false;
    $('islandViewport').style.cursor = 'grab';
    await set(ref(db, `villages/${state.currentVillage.id}/underAttack`), false);
    loading(false);
    return;
  }
  
  // Restar un avi√≥n
  await set(ref(db, `users/${state.user}/inventory/bomberPlanes`), bomberCount - 1);
  
  // MARCAR BOMBARDERO COMO ACTIVO
  state.bomberActive = true;
  
  const attackTarget = {row: r, col: c, owner: state.currentVillage.owner, id: state.currentVillage.id};
  
  // Crear el avi√≥n en la parte inferior de la pantalla
  const targetCell = $('islandGrid').querySelector(`[data-row="${r}"][data-col="${c}"]`);
  if (!targetCell) {
    alert('Error: No se pudo encontrar la celda objetivo');
    loading(false);
    return;
  }
  
  const targetRect = targetCell.getBoundingClientRect();
  const startX = targetRect.left + targetRect.width / 2;
  const startY = window.innerHeight + 50;
  
  const plane = document.createElement('div');
  plane.style.position = 'fixed';
  plane.style.fontSize = '50px';
  plane.style.left = startX - 25 + 'px';
  plane.style.top = startY + 'px';
  plane.style.zIndex = '10001';
  plane.textContent = '‚úàÔ∏è';
  plane.style.filter = 'drop-shadow(0 0 10px rgba(100, 100, 255, 0.8))';
  document.body.appendChild(plane);
  
  // VERIFICAR SI HAY TORRETAS ANTI-A√âREAS que disparen cada 0.5s
  const aaTurrets = state.buildings.aaTurrets || [];
  let planeDestroyed = false;
  let planeHealth = 3; // El avi√≥n aguanta 3 impactos
  
  if (aaTurrets.length > 0) {
    // Intervalo para que las torretas disparen cada 0.5 segundos
    const aaInterval = setInterval(() => {
      if (planeDestroyed) {
        clearInterval(aaInterval);
        return;
      }
      
      // Cada torreta impacta (100% de probabilidad)
      for (const turret of aaTurrets) {
        if (planeDestroyed) break;
        
        // Verificar que la torre NO est√© destruida
        const isDestroyed = turret.destroyed || (turret.health !== undefined && turret.health <= 0);
        if (isDestroyed) continue; // Torre destruida no puede disparar
        
        planeHealth--; // Reducir vida del avi√≥n
        
        // Efecto visual de la torreta disparando
        const turretCell = $('islandGrid').querySelector(`[data-row="${turret.row}"][data-col="${turret.col}"]`);
        if (turretCell) {
          const turretRect = turretCell.getBoundingClientRect();
          const planeRect = plane.getBoundingClientRect();
          
          // Efecto de brillo en la torreta
          turretCell.style.boxShadow = '0 0 30px #FF6347, 0 0 50px #FF4500';
          setTimeout(() => turretCell.style.boxShadow = '', 1000);
          
          // Crear misil de la torreta
          const missile = document.createElement('div');
          missile.style.position = 'fixed';
          missile.style.fontSize = '20px';
          missile.style.left = (turretRect.left + turretRect.width / 2) + 'px';
          missile.style.top = (turretRect.top + turretRect.height / 2) + 'px';
          missile.style.zIndex = '10002';
          missile.textContent = 'üöÄ';
          missile.style.transition = 'all 0.5s linear';
          document.body.appendChild(missile);
          
          // Animar misil hacia el avi√≥n
          setTimeout(() => {
            missile.style.left = (planeRect.left + planeRect.width / 2) + 'px';
            missile.style.top = (planeRect.top + planeRect.height / 2) + 'px';
          }, 50);
          
          // Impacto despu√©s de 500ms
          setTimeout(async () => {
            missile.remove();
            
            // Peque√±a explosi√≥n de impacto
            const hitExplosion = document.createElement('div');
            hitExplosion.style.position = 'fixed';
            hitExplosion.style.fontSize = '40px';
            hitExplosion.style.left = (planeRect.left + planeRect.width / 2 - 20) + 'px';
            hitExplosion.style.top = (planeRect.top + planeRect.height / 2 - 20) + 'px';
            hitExplosion.style.zIndex = '10003';
            hitExplosion.textContent = 'üí•';
            hitExplosion.style.animation = 'explode 0.5s ease-out forwards';
            document.body.appendChild(hitExplosion);
            setTimeout(() => hitExplosion.remove(), 500);
            
            // Si la vida llega a 0, destruir el avi√≥n
            if (planeHealth <= 0 && !planeDestroyed) {
              planeDestroyed = true;
              clearInterval(aaInterval);
              plane.remove();
              
              // Explosi√≥n grande en el aire
              const explosion = document.createElement('div');
              explosion.style.position = 'fixed';
              explosion.style.fontSize = '80px';
              explosion.style.left = (planeRect.left + planeRect.width / 2 - 40) + 'px';
              explosion.style.top = (planeRect.top + planeRect.height / 2 - 40) + 'px';
              explosion.style.zIndex = '10003';
              explosion.textContent = 'üí•';
              explosion.style.animation = 'explode 1s ease-out forwards';
              document.body.appendChild(explosion);
              
              setTimeout(() => explosion.remove(), 1000);
              
              // Mensaje de defensa exitosa (solo una vez)
              showXPNotification(0, window.innerWidth / 2 - 100, window.innerHeight / 2, 'üóº AVI√ìN DERRIBADO!');
              
              // Desbloquear logro
              await unlockAchievement('planeDestroyer');
              
              state.bomberActive = false;
              state.attacking = false;
              state.placing = null;
              state.dragLocked = false;
              $('islandViewport').style.cursor = 'grab';
              loading(false);
            }
          }, 500);
        }
        
        break;
      }
    }, 700); // Disparar cada 0.7 segundos
    
    // Limpiar el intervalo despu√©s de 5 segundos (duraci√≥n del vuelo)
    setTimeout(() => {
      clearInterval(aaInterval);
    }, 5000);
  }
  
  // Si el avi√≥n fue derribado, terminar la funci√≥n aqu√≠
  if (planeDestroyed) {
    await set(ref(db, `villages/${attackTarget.id}/underAttack`), false);
    return;
  }
  
  // Variables para la animaci√≥n
  const planeStartTime = Date.now();
  const planeDuration = 5000; // 5 segundos para subir
  const planeStartY = startY;
  const planeEndY = -100;
  
  // Array para guardar las celdas da√±adas
  const damagedCells = [];
  let bombCount = 0;
  
  // Part√≠culas de humo del avi√≥n
  const smokeInterval = setInterval(() => {
    // Detener si el avi√≥n fue destruido
    if (planeDestroyed) {
      clearInterval(smokeInterval);
      return;
    }
    
    const elapsed = Date.now() - planeStartTime;
    const progress = Math.min(elapsed / planeDuration, 1);
    const currentPlaneY = planeStartY - (progress * (planeStartY - planeEndY));
    
    if (progress >= 1) {
      clearInterval(smokeInterval);
      return;
    }
    
    for (let i = 0; i < 2; i++) {
      const smoke = document.createElement('div');
      smoke.style.position = 'fixed';
      smoke.style.left = (startX + (Math.random() - 0.5) * 20) + 'px';
      smoke.style.top = (currentPlaneY + 40) + 'px';
      smoke.style.width = (10 + Math.random() * 15) + 'px';
      smoke.style.height = (10 + Math.random() * 15) + 'px';
      smoke.style.borderRadius = '50%';
      const opacity = 0.5 + Math.random() * 0.3;
      const gray = 160 + Math.random() * 95;
      smoke.style.background = `rgba(${gray}, ${gray}, ${gray}, ${opacity})`;
      smoke.style.boxShadow = `0 0 10px rgba(255, 255, 255, 0.4)`;
      smoke.style.zIndex = '9999';
      smoke.style.pointerEvents = 'none';
      document.body.appendChild(smoke);
      
      const spreadX = (Math.random() - 0.5) * 40;
      const spreadY = Math.random() * 50 + 40;
      const duration = 1200 + Math.random() * 600;
      smoke.style.transition = `all ${duration}ms ease-out`;
      
      setTimeout(() => {
        smoke.style.transform = `translate(${spreadX}px, ${spreadY}px) scale(2)`;
        smoke.style.opacity = '0';
      }, 50);
      
      setTimeout(() => smoke.remove(), duration + 100);
    }
  }, 80);
  
  // Soltar bombas cada 0.7 segundos
  const bombInterval = setInterval(async () => {
    // Detener si el avi√≥n fue destruido
    if (planeDestroyed) {
      clearInterval(bombInterval);
      return;
    }
    
    const elapsed = Date.now() - planeStartTime;
    const progress = Math.min(elapsed / planeDuration, 1);
    
    if (progress >= 1 || bombCount >= 8) {
      clearInterval(bombInterval);
      return;
    }
    
    // Posici√≥n actual del avi√≥n
    const currentPlaneY = planeStartY - (progress * (planeStartY - planeEndY));
    
    // Crear mini cohete/bomba
    const bomb = document.createElement('div');
    bomb.style.position = 'fixed';
    bomb.style.fontSize = '25px';
    bomb.style.left = (startX - 12) + 'px';
    bomb.style.top = currentPlaneY + 'px';
    bomb.style.zIndex = '10000';
    bomb.textContent = 'üí£';
    bomb.style.transition = 'top 0.8s ease-in';
    document.body.appendChild(bomb);
    
    // Calcular celda objetivo (en l√≠nea recta hacia arriba desde el punto de click)
    const bombTargetRow = Math.max(0, r - bombCount);
    const bombTargetCol = c;
    bombCount++;
    
    const bombTargetCell = $('islandGrid').querySelector(`[data-row="${bombTargetRow}"][data-col="${bombTargetCol}"]`);
    if (bombTargetCell) {
      const bombTargetRect = bombTargetCell.getBoundingClientRect();
      
      setTimeout(() => {
        bomb.style.top = (bombTargetRect.top + bombTargetRect.height / 2) + 'px';
      }, 50);
      
      // Explosi√≥n despu√©s de 800ms
      setTimeout(async () => {
        bomb.remove();
        createExplosion(bombTargetRect.left + bombTargetRect.width / 2, bombTargetRect.top + bombTargetRect.height / 2);
        
        // Efecto de temblor
        const viewport = $('islandViewport');
        viewport.classList.add('shake');
        setTimeout(() => viewport.classList.remove('shake'), 500);
        
        // Da√±o 3x3
        let castleHitThisBomb = false;
        
        for (let dx = -1; dx <= 1; dx++) {
          for (let dy = -1; dy <= 1; dy++) {
            const nr = bombTargetRow + dx, nc = bombTargetCol + dy;
            if (nr >= 0 && nr < 20 && nc >= 0 && nc < 20) {
              // Verificar si impact√≥ el castillo
              if (nr === 10 && nc === 10) {
                castleHitThisBomb = true;
                continue;
              }
              
              const cellKey = `${nr}-${nc}`;
              if (!damagedCells.includes(cellKey)) {
                // Verificar si hay alguna estructura en esta posici√≥n
                const hasMine = state.buildings.mines.some(m => m.row === nr && m.col === nc);
                const hasRocket = state.buildings.rocketLaunchers.some(rl => rl.row === nr && rl.col === nc);
                const hasAATurret = state.buildings.aaTurrets.some(aa => aa.row === nr && aa.col === nc);
                const hasDeflector = state.buildings.deflectorTowers.some(dt => dt.row === nr && dt.col === nc);
                const hasStatue = state.buildings.statues.some(s => s.row === nr && s.col === nc);
                const hasFlower = state.buildings.flowers.some(f => f.row === nr && f.col === nc);
                const alreadyDamaged = state.buildings.damaged.some(d => d.row === nr && d.col === nc);
                
                if (!hasMine && !hasRocket && !hasAATurret && !hasDeflector && !hasStatue && !hasFlower && !alreadyDamaged) {
                  const target = $('islandGrid').querySelector(`[data-row="${nr}"][data-col="${nc}"]`);
                  if (target) {
                    state.buildings.damaged.push({row: nr, col: nc});
                    target.classList.add('damaged');
                    damagedCells.push(cellKey);
                  }
                }
              }
            }
          }
        }
        
        // Si el castillo fue impactado, reducir su salud
        if (castleHitThisBomb) {
          const villageRef = ref(db, `villages/${attackTarget.id}`);
          const villageSnap = await get(villageRef);
          if (villageSnap.exists()) {
            const villageData = villageSnap.val();
            let castleHealth = villageData.castleHealth !== undefined ? villageData.castleHealth : 500;
            const maxHealth = villageData.castleMaxHealth || 500;
            castleHealth = Math.max(0, castleHealth - 40); // Cada bomba hace 40 de da√±o
            
            await set(villageRef, {
              ...villageData,
              castleHealth: castleHealth
            });
            
            state.currentVillage.castleHealth = castleHealth;
            
            // Actualizar barra de vida
            updateCastleHealthBar();
            
            // Actualizar visual del castillo
            const castleCell = $('islandGrid').querySelector(`[data-row="10"][data-col="10"]`);
            if (castleCell) {
              if (castleHealth <= 0) {
                castleCell.textContent = 'üï≥Ô∏è';
                castleCell.classList.remove('my-castle', 'enemy-castle');
                castleCell.classList.add('destroyed-castle');
                // Remover barra de vida
                const healthBar = castleCell.querySelector('.health-bar-container');
                const healthText = castleCell.querySelector('.health-text');
                if (healthBar) healthBar.remove();
                if (healthText) healthText.remove();
                showXPNotification(0, window.innerWidth / 2 - 100, window.innerHeight / 2, 'üí• ¬°CASTILLO DESTRUIDO!');
              } else {
                showXPNotification(0, window.innerWidth / 2 - 100, window.innerHeight / 2 - 50, `‚úàÔ∏è -40 HP | ${castleHealth}/${maxHealth}`);
              }
            }
          }
        }
      }, 800);
    } else {
      setTimeout(() => bomb.remove(), 1000);
    }
  }, 700);
  
  // Animar avi√≥n subiendo
  const animatePlane = () => {
    // Detener animaci√≥n si el avi√≥n fue destruido
    if (planeDestroyed) {
      return;
    }
    
    const elapsed = Date.now() - planeStartTime;
    const progress = Math.min(elapsed / planeDuration, 1);
    const currentY = planeStartY - (progress * (planeStartY - planeEndY));
    plane.style.top = currentY + 'px';
    
    if (progress > 0.8) {
      plane.style.opacity = (1 - (progress - 0.8) / 0.2).toString();
    }
    
    if (progress < 1) {
      requestAnimationFrame(animatePlane);
    } else {
      plane.remove();
    }
  };
  
  requestAnimationFrame(animatePlane);
  
  // Esperar a que termine la animaci√≥n
  await new Promise(resolve => setTimeout(resolve, planeDuration + 1000));
  
  // Limpiar intervalos
  clearInterval(smokeInterval);
  clearInterval(bombInterval);
  
  // DESACTIVAR FLAG DE BOMBARDERO
  state.bomberActive = false;
  
  // Guardar da√±os
  await set(ref(db, `users/${attackTarget.owner}/buildings`), {
    goldMines: state.buildings.mines,
    rocketLaunchers: state.buildings.rocketLaunchers,
    superRocketLaunchers: state.buildings.superRocketLaunchers,
    aaTurrets: state.buildings.aaTurrets,
    deflectorTowers: state.buildings.deflectorTowers,
    statues: state.buildings.statues,
    flowers: state.buildings.flowers,
    damaged: state.buildings.damaged
  });
  
  // Dar XP al atacante
  const attackerLevelSnap = await get(ref(db, `users/${state.user}/level`));
  if (attackerLevelSnap.exists()) {
    let attackerLevel = attackerLevelSnap.val();
    attackerLevel.xp = (attackerLevel.xp || 0) + 40;
    
    while (attackerLevel.xp >= attackerLevel.needed && attackerLevel.level < 20) {
      attackerLevel.xp -= attackerLevel.needed;
      attackerLevel.level++;
      attackerLevel.needed = attackerLevel.level * 100;
    }
    
    if (attackerLevel.level >= 20) attackerLevel.xp = Math.min(attackerLevel.xp, attackerLevel.needed - 1);
    
    await set(ref(db, `users/${state.user}/level`), attackerLevel);
  }
  
  state.attacking = false;
  state.placing = null;
  state.dragLocked = false;
  $('islandViewport').style.cursor = 'grab';
  await set(ref(db, `villages/${attackTarget.id}/underAttack`), false);
  
  showXPNotification(40, window.innerWidth / 2 - 50, window.innerHeight / 2);
  loading(false);
}
// Funci√≥n para mostrar notificaci√≥n de XP estilo COD
function showXPNotification(xp, x, y, message = '') {
  const notification = document.createElement('div');
  notification.className = 'xp-notification';
  notification.style.left = x + 'px';
  notification.style.top = y + 'px';
  
  if (message) {
    notification.textContent = message;
  } else {
    notification.textContent = `+${xp} XP`;
  }
  
  document.body.appendChild(notification);
  
  setTimeout(() => notification.remove(), 2000);
}

function createExplosion(x, y) {
  // Reproducir sonido de explosi√≥n
  const explosionSound = $('explosionSound');
  explosionSound.currentTime = 0;
  explosionSound.volume = 0.4;
  explosionSound.play().catch(e => console.log('Error reproduciendo sonido:', e));
  
  const colors = ['#ff4500', '#ff6347', '#ff8c00', '#ffa500', '#ffff00', '#ff0000'];
  const particleCount = 50;
 
  for (let i = 0; i < particleCount; i++) {
    const particle = document.createElement('div');
    particle.className = 'explosion-particle';
    particle.style.left = x + 'px';
    particle.style.top = y + 'px';
    particle.style.background = colors[Math.floor(Math.random() * colors.length)];
   
    const angle = (Math.PI * 2 * i) / particleCount;
    const velocity = 100 + Math.random() * 150;
    const tx = Math.cos(angle) * velocity;
    const ty = Math.sin(angle) * velocity;
   
    particle.style.animation = `explode 1s ease-out forwards`;
    particle.style.transform = `translate(${tx}px, ${ty}px) scale(${Math.random() * 2 + 0.5})`;
   
    document.body.appendChild(particle);
   
    setTimeout(() => particle.remove(), 1000);
  }
 
  // Flash de explosi√≥n
  const flash = document.createElement('div');
  flash.style.position = 'fixed';
  flash.style.left = x - 100 + 'px';
  flash.style.top = y - 100 + 'px';
  flash.style.width = '200px';
  flash.style.height = '200px';
  flash.style.borderRadius = '50%';
  flash.style.background = 'radial-gradient(circle, rgba(255,255,255,0.9) 0%, rgba(255,100,0,0.7) 30%, rgba(255,0,0,0) 70%)';
  flash.style.zIndex = '10002';
  flash.style.pointerEvents = 'none';
  flash.style.animation = 'explode 0.5s ease-out forwards';
  document.body.appendChild(flash);
  setTimeout(() => flash.remove(), 500);
}
// Resource Management
async function loadResources(owner) {
  const snap = await get(ref(db, `users/${owner}/resources`));
  let res = snap.exists() ? snap.val() : {gold: 100, lastUpdate: Date.now()};
  state.resources.gold = res.gold || 100;
 
  // Solo calcular oro offline y dar XP si es TU aldea
  if (owner === state.user) {
    const buildSnap = await get(ref(db, `users/${owner}/buildings`));
    const buildings = buildSnap.exists() ? buildSnap.val() : {};
    const mineCount = (buildings.goldMines || buildings.mines || []).length;
   
    const delta = Date.now() - (res.lastUpdate || Date.now());
    const ticks = Math.floor(delta / 5000);
    
    if (mineCount > 0 && ticks > 0) {
      // L√çMITE DE CAPACIDAD: M√°ximo 10,000 oro
      const MAX_GOLD_CAPACITY = 10000;
      const goldToGenerate = ticks * 10 * mineCount;
      const goldBeforeGeneration = state.resources.gold;
      
      // Solo generar oro si no se ha alcanzado el l√≠mite
      if (goldBeforeGeneration < MAX_GOLD_CAPACITY) {
        const availableSpace = MAX_GOLD_CAPACITY - goldBeforeGeneration;
        const goldGenerated = Math.min(goldToGenerate, availableSpace);
        state.resources.gold += goldGenerated;
        
        // Notificar si se alcanz√≥ el l√≠mite de capacidad
        if (goldBeforeGeneration + goldToGenerate >= MAX_GOLD_CAPACITY) {
          alert(`‚ö†Ô∏è ¬°Capacidad de oro alcanzada!\n\nüí∞ Oro: ${state.resources.gold.toLocaleString()} / ${MAX_GOLD_CAPACITY.toLocaleString()}\nüõë Las minas dejaron de generar oro\n\nüí° Gasta oro para que las minas vuelvan a producir`);
        }
      }
      
      // addXP ya verifica internamente si es tu aldea, pero aqu√≠ estamos seguros
      await addXP(ticks);
      await checkAchievements();
    }
    await set(ref(db, `users/${owner}/resources`), {gold: state.resources.gold, lastUpdate: Date.now()});
  }
 
  updateUI();
}
async function loadLevel(owner) {
  const snap = await get(ref(db, `users/${owner}/level`));
  if (snap.exists()) {
    const d = snap.val();
    state.level = {level: d.level || 1, xp: d.xp || 0, needed: (d.level || 1) * 100};
  } else {
    state.level = {level: 1, xp: 0, needed: 100};
    if (owner === state.user) await set(ref(db, `users/${owner}/level`), state.level);
  }
  updateUI();
}
async function loadBuildings(owner) {
  const snap = await get(ref(db, `users/${owner}/buildings`));
  const b = snap.exists() ? snap.val() : {};
  state.buildings = {
    mines: b.goldMines || b.mines || [],
    rocketLaunchers: b.rocketLaunchers || [],
    superRocketLaunchers: b.superRocketLaunchers || [],
    aaTurrets: b.aaTurrets || [],
    deflectorTowers: b.deflectorTowers || [],
    statues: b.statues || [],
    flowers: b.flowers || [],
    damaged: b.damaged || []
  };
  updateShop();
}
async function addXP(amount) {
  // CR√çTICO: Solo dar XP si est√°s en tu propia aldea
  if (state.currentVillage.owner !== state.user) {
    return; // No dar XP si est√°s viendo la aldea de otro jugador
  }
  
  let {level, xp, needed} = state.level;
  xp += amount;
 
  while (xp >= needed && level < 20) {
    xp -= needed;
    level++;
    needed = level * 100;
    alert(`¬°Felicidades! ${state.user} subi√≥ al nivel ${level}`);
  }
 
  if (level >= 20) xp = Math.min(xp, needed - 1);
 
  state.level = {level, xp, needed};
  await set(ref(db, `users/${state.user}/level`), state.level);
  updateUI();
  await checkAchievements();
}
function startGoldGen() {
  if (state.intervals.gold) return;
  const firstDelay = 5000 - (Date.now() % 5000);
  const MAX_GOLD_CAPACITY = 10000;
 
  setTimeout(async () => {
    if (state.currentVillage.owner === state.user && state.buildings.mines.length > 0) {
      // Solo generar oro si no se ha alcanzado el l√≠mite
      if (state.resources.gold < MAX_GOLD_CAPACITY) {
        const goldToAdd = 10 * state.buildings.mines.length;
        state.resources.gold = Math.min(state.resources.gold + goldToAdd, MAX_GOLD_CAPACITY);
        await addXP(1);
        updateUI();
        await set(ref(db, `users/${state.user}/resources`), {gold: state.resources.gold, lastUpdate: Date.now()});
      }
    }
   
    state.intervals.gold = setInterval(async () => {
      if (state.currentVillage.owner === state.user && state.buildings.mines.length > 0) {
        // Solo generar oro si no se ha alcanzado el l√≠mite
        if (state.resources.gold < MAX_GOLD_CAPACITY) {
          const goldToAdd = 10 * state.buildings.mines.length;
          state.resources.gold = Math.min(state.resources.gold + goldToAdd, MAX_GOLD_CAPACITY);
          await addXP(1);
          updateUI();
          await set(ref(db, `users/${state.user}/resources`), {gold: state.resources.gold, lastUpdate: Date.now()});
        }
      }
    }, 5000);
  }, firstDelay);
}
// UI Updates
function updateUI() {
  const MAX_GOLD_CAPACITY = 10000;
  const goldPercent = Math.min((state.resources.gold / MAX_GOLD_CAPACITY) * 100, 100);
  
  $('goldAmount').textContent = state.resources.gold.toLocaleString();
  
  // Actualizar barra de capacidad de oro
  const goldBar = $('goldCapacityBar');
  goldBar.style.width = goldPercent + '%';
  
  // Cambiar color si est√° lleno
  if (state.resources.gold >= MAX_GOLD_CAPACITY) {
    goldBar.classList.add('full');
  } else {
    goldBar.classList.remove('full');
  }
  
  $('userName').textContent = state.currentVillage.owner;
  $('userLevel').textContent = state.level.level;
  const pct = (state.level.xp / state.level.needed) * 100;
  $('xpBar').style.width = pct + '%';
  $('xpBarText').textContent = `${state.level.xp} / ${state.level.needed} XP`;
}
function updateTowerHealthVisuals() {
  // Actualizar visual de torres AA
  state.buildings.aaTurrets.forEach(t => {
    const cell = $('islandGrid').querySelector(`[data-row="${t.row}"][data-col="${t.col}"]`);
    if (!cell) return;
    
    const health = t.health !== undefined ? t.health : 150;
    const maxHealth = 150;
    const isDestroyed = t.destroyed || health <= 0;
    const isDamaged = health < maxHealth;
    
    if (isDestroyed) {
      if (cell.textContent !== 'üî•') {
        cell.textContent = 'üî•';
        cell.style.opacity = '0.6';
        cell.classList.add('destroyed-structure');
        const healthBar = cell.querySelector('.health-bar-container');
        const healthText = cell.querySelector('.health-text');
        if (healthBar) healthBar.remove();
        if (healthText) healthText.remove();
      }
    } else if (isDamaged) {
      if (!cell.querySelector('.health-bar-container')) {
        const healthBarContainer = document.createElement('div');
        healthBarContainer.className = 'health-bar-container';
        const healthBar = document.createElement('div');
        healthBar.className = 'health-bar';
        const healthText = document.createElement('div');
        healthText.className = 'health-text';
        healthBarContainer.appendChild(healthBar);
        cell.appendChild(healthBarContainer);
        cell.appendChild(healthText);
      }
      const healthBar = cell.querySelector('.health-bar');
      const healthText = cell.querySelector('.health-text');
      if (healthBar && healthText) {
        const healthPercent = (health / maxHealth) * 100;
        healthBar.style.width = healthPercent + '%';
        healthBar.classList.remove('low', 'medium');
        if (healthPercent <= 25) healthBar.classList.add('low');
        else if (healthPercent <= 50) healthBar.classList.add('medium');
        healthText.textContent = `${health}/${maxHealth}`;
      }
    }
  });
  
  // Actualizar visual de torres desviadoras
  state.buildings.deflectorTowers.forEach(dt => {
    const cell = $('islandGrid').querySelector(`[data-row="${dt.row}"][data-col="${dt.col}"]`);
    if (!cell) return;
    
    const health = dt.health !== undefined ? dt.health : 150;
    const maxHealth = 150;
    const isDestroyed = dt.destroyed || health <= 0;
    const isDamaged = health < maxHealth;
    
    if (isDestroyed) {
      if (cell.textContent !== 'üî•') {
        cell.textContent = 'üî•';
        cell.style.opacity = '0.6';
        cell.classList.add('destroyed-structure');
        const healthBar = cell.querySelector('.health-bar-container');
        const healthText = cell.querySelector('.health-text');
        if (healthBar) healthBar.remove();
        if (healthText) healthText.remove();
      }
    } else if (isDamaged) {
      if (!cell.querySelector('.health-bar-container')) {
        const healthBarContainer = document.createElement('div');
        healthBarContainer.className = 'health-bar-container';
        const healthBar = document.createElement('div');
        healthBar.className = 'health-bar';
        const healthText = document.createElement('div');
        healthText.className = 'health-text';
        healthBarContainer.appendChild(healthBar);
        cell.appendChild(healthBarContainer);
        cell.appendChild(healthText);
      }
      const healthBar = cell.querySelector('.health-bar');
      const healthText = cell.querySelector('.health-text');
      if (healthBar && healthText) {
        const healthPercent = (health / maxHealth) * 100;
        healthBar.style.width = healthPercent + '%';
        healthBar.classList.remove('low', 'medium');
        if (healthPercent <= 25) healthBar.classList.add('low');
        else if (healthPercent <= 50) healthBar.classList.add('medium');
        healthText.textContent = `${health}/${maxHealth}`;
      }
    }
  });
}
function updateCastleHealthBar() {
  const healthBar = document.getElementById('castle-health-bar');
  const healthText = document.getElementById('castle-health-text');
  
  if (!healthBar || !healthText) return;
  
  const currentHealth = state.currentVillage.castleHealth || 500;
  const maxHealth = state.currentVillage.castleMaxHealth || 500;
  const healthPercent = (currentHealth / maxHealth) * 100;
  
  healthBar.style.width = healthPercent + '%';
  healthText.textContent = `${currentHealth} / ${maxHealth}`;
  
  // Cambiar color seg√∫n el porcentaje de vida
  healthBar.classList.remove('medium', 'low');
  if (healthPercent <= 25) {
    healthBar.classList.add('low');
  } else if (healthPercent <= 50) {
    healthBar.classList.add('medium');
  }
}
function updateShop() {
  $('mineCount').textContent = state.buildings.mines.length;
  $('rocketLauncherCount').textContent = state.buildings.rocketLaunchers.length;
  $('aaTurretCount').textContent = state.buildings.aaTurrets.length;
  $('buyMineBtn').disabled = state.buildings.mines.length >= 2;
  $('buyMineBtn').textContent = state.buildings.mines.length >= 2 ? 'M√°ximo alcanzado' : 'Comprar';
  $('buyRocketLauncherBtn').disabled = state.buildings.rocketLaunchers.length >= 1;
  $('buyRocketLauncherBtn').textContent = state.buildings.rocketLaunchers.length >= 1 ? 'M√°ximo alcanzado' : 'Comprar';
  $('buyAATurretBtn').disabled = state.buildings.aaTurrets.length >= 2;
  $('buyAATurretBtn').textContent = state.buildings.aaTurrets.length >= 2 ? 'M√°ximo alcanzado' : 'Comprar';
}

// Market Functions
const ITEM_NAMES = {
  'statue': 'üóø Estatua Moai',
  'flower': 'üå∏ Flor Decorativa',
  'rocket': 'üöÄ Munici√≥n de Cohete',
  'superRocket': 'üí• Super Cohete',
  'bomber': '‚úàÔ∏è Avi√≥n Bombardero',
  'deflectorTower': 'üõ°Ô∏è Torre Desviadora',
  'mine': '‚õèÔ∏è Mina de Oro',
  'rocketLauncher': 'üöÄ Lanza Cohetes',
  'superRocketLauncher': 'üí• Super Lanzador',
  'aaTurret': 'üóº Torreta Anti-A√©rea',
  'bomb': 'üí£ Bomba'
};

async function openMarket() {
  loading(true);
  
  // Cancelar cualquier modo de colocaci√≥n activo para prevenir duplicaciones
  state.placing = null;
  
  show(modal('market'));
  
  // Reproducir m√∫sica de la tienda
  const shopMusic = $('shopMusic');
  shopMusic.volume = 0.15; // Volumen al 15%
  shopMusic.currentTime = 0; // Reiniciar desde el inicio
  shopMusic.play().catch(err => console.log('Error al reproducir m√∫sica:', err));
  
  // Actualizar oro
  const goldSnap = await get(ref(db, `users/${state.user}/resources`));
  if (goldSnap.exists()) {
    state.resources.gold = goldSnap.val().gold || 0;
  }
  $('marketGold').textContent = state.resources.gold;
  
  // Cargar ofertas de compra
  await loadMarketOffers();
  
  // Configurar buscador
  const searchInput = $('marketSearchBuy');
  searchInput.value = ''; // Limpiar buscador
  searchInput.oninput = (e) => {
    const searchTerm = e.target.value.toLowerCase().trim();
    const offers = document.querySelectorAll('.market-offer-item');
    const titleDiv = document.querySelector('#marketBuyList > div:first-child');
    
    if (searchTerm === '') {
      // Si est√° vac√≠o, mostrar todos y el t√≠tulo de "Productos Recomendados"
      if (titleDiv) titleDiv.style.display = 'block';
      offers.forEach(offer => {
        offer.style.display = 'block';
      });
    } else {
      // Ocultar t√≠tulo cuando se busca
      if (titleDiv) titleDiv.style.display = 'none';
      
      // Filtrar por nombre del item o vendedor
      offers.forEach(offer => {
        const itemName = offer.dataset.itemName || '';
        const seller = offer.dataset.seller || '';
        
        if (itemName.includes(searchTerm) || seller.includes(searchTerm)) {
          offer.style.display = 'block';
        } else {
          offer.style.display = 'none';
        }
      });
    }
  };
  
  // Configurar pesta√±as
  document.querySelectorAll('#marketModal .shop-tab').forEach(tab => {
    tab.onclick = () => {
      document.querySelectorAll('#marketModal .shop-tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('#marketModal .shop-category').forEach(c => c.classList.remove('active'));
      tab.classList.add('active');
      const targetId = tab.dataset.tab;
      document.getElementById(targetId).classList.add('active');
      
      if (targetId === 'market-sell') loadMarketSellInventory();
      else if (targetId === 'market-my') loadMyMarketOffers();
      else if (targetId === 'market-buy') $('marketSearchBuy').value = '';
    }
  });
  
  loading(false);
}

async function loadMarketOffers() {
  const offersSnap = await get(ref(db, 'market'));
  const buyList = $('marketBuyList');
  buyList.innerHTML = '';
  
  // Agregar t√≠tulo de productos recomendados
  const titleDiv = document.createElement('div');
  titleDiv.style.gridColumn = '1/-1';
  titleDiv.innerHTML = '<h3 style="color: #fff; margin-bottom: 10px; text-shadow: 2px 2px 4px rgba(0,0,0,0.5);">üì¶ Productos Recomendados</h3>';
  buyList.appendChild(titleDiv);
  
  if (!offersSnap.exists()) {
    const emptyDiv = document.createElement('div');
    emptyDiv.style.gridColumn = '1/-1';
    emptyDiv.innerHTML = '<p style="text-align: center; color: #666; padding: 40px;">No hay ofertas disponibles en el mercado</p>';
    buyList.appendChild(emptyDiv);
    return;
  }
  
  const offers = offersSnap.val();
  let hasOffers = false;
  
  Object.entries(offers).forEach(([offerId, offer]) => {
    if (offer.seller === state.user) return; // No mostrar mis propias ofertas en comprar
    
    hasOffers = true;
    const itemName = ITEM_NAMES[offer.item] || offer.item;
    const emoji = itemName.split(' ')[0];
    const name = itemName.split(' ').slice(1).join(' ');
    
    const offerDiv = document.createElement('div');
    offerDiv.className = 'market-offer-item';
    offerDiv.dataset.itemName = name.toLowerCase();
    offerDiv.dataset.seller = offer.seller.toLowerCase();
    offerDiv.style.border = '2px solid #667eea';
    offerDiv.style.borderRadius = '10px';
    offerDiv.style.padding = '20px';
    offerDiv.style.background = 'white';
    offerDiv.style.boxShadow = '0 2px 8px rgba(0,0,0,0.1)';
    offerDiv.style.transition = 'transform 0.2s, box-shadow 0.2s';
    offerDiv.onmouseenter = () => {
      offerDiv.style.transform = 'translateY(-5px)';
      offerDiv.style.boxShadow = '0 4px 12px rgba(0,0,0,0.2)';
    };
    offerDiv.onmouseleave = () => {
      offerDiv.style.transform = 'translateY(0)';
      offerDiv.style.boxShadow = '0 2px 8px rgba(0,0,0,0.1)';
    };
    offerDiv.innerHTML = `
      <div style="font-size: 48px; text-align: center; margin-bottom: 15px;">${emoji}</div>
      <div style="font-size: 16px; font-weight: bold; text-align: center; margin-bottom: 10px; color: #333;">${name}</div>
      <div style="color: #666; margin-bottom: 10px; text-align: center; font-size: 13px;">üë§ ${offer.seller}</div>
      <div style="background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%); color: #000; font-size: 18px; font-weight: bold; padding: 10px; border-radius: 8px; text-align: center; margin-bottom: 15px; box-shadow: 0 2px 4px rgba(0,0,0,0.2);">üí∞ ${offer.price} Oro</div>
      <button onclick="buyMarketItem('${offerId}', ${offer.price})" style="width: 100%; padding: 12px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: bold; font-size: 14px; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">üõí Comprar</button>
    `;
    buyList.appendChild(offerDiv);
  });
  
  if (!hasOffers) {
    const emptyDiv = document.createElement('div');
    emptyDiv.style.gridColumn = '1/-1';
    emptyDiv.innerHTML = '<p style="text-align: center; color: #666; padding: 40px;">No hay ofertas de otros jugadores disponibles</p>';
    buyList.appendChild(emptyDiv);
  }
}

async function loadMarketSellInventory() {
  const inventorySnap = await get(ref(db, `users/${state.user}/inventory`));
  const sellInventory = $('marketSellInventory');
  sellInventory.innerHTML = '';
  
  const items = inventorySnap.exists() ? (inventorySnap.val().items || []) : [];
  const rockets = inventorySnap.exists() ? (inventorySnap.val().rockets || 0) : 0;
  const bombers = inventorySnap.exists() ? (inventorySnap.val().bombers || 0) : 0;
  
  if (items.length === 0 && rockets === 0 && bombers === 0) {
    sellInventory.innerHTML = '<p style="text-align: center; color: #666; padding: 40px; grid-column: 1/-1;">No tienes objetos para vender</p>';
    return;
  }
  
  // Agregar items del inventario
  items.forEach(item => {
    const itemDiv = document.createElement('div');
    itemDiv.style.border = '2px solid #4CAF50';
    itemDiv.style.borderRadius = '10px';
    itemDiv.style.padding = '20px';
    itemDiv.style.background = 'white';
    itemDiv.style.boxShadow = '0 2px 8px rgba(0,0,0,0.1)';
    itemDiv.style.transition = 'transform 0.2s, box-shadow 0.2s';
    itemDiv.style.cursor = 'pointer';
    itemDiv.onmouseenter = () => {
      itemDiv.style.transform = 'translateY(-5px)';
      itemDiv.style.boxShadow = '0 4px 12px rgba(0,0,0,0.2)';
    };
    itemDiv.onmouseleave = () => {
      itemDiv.style.transform = 'translateY(0)';
      itemDiv.style.boxShadow = '0 2px 8px rgba(0,0,0,0.1)';
    };
    itemDiv.innerHTML = `
      <div style="font-size: 48px; text-align: center; margin-bottom: 15px;">${ITEM_NAMES[item]?.split(' ')[0] || 'üì¶'}</div>
      <div style="font-size: 16px; font-weight: bold; text-align: center; margin-bottom: 15px; color: #333;">${ITEM_NAMES[item]?.split(' ').slice(1).join(' ') || item}</div>
      <button onclick="sellMarketItem('${item}')" style="width: 100%; padding: 12px; background: linear-gradient(135deg, #89ff00 0%, #00bcd4 100%); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: bold; font-size: 14px; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">üí∞ Vender</button>
    `;
    sellInventory.appendChild(itemDiv);
  });
  
  // Agregar cohetes
  if (rockets > 0) {
    const rocketDiv = document.createElement('div');
    rocketDiv.style.border = '2px solid #FF6347';
    rocketDiv.style.borderRadius = '10px';
    rocketDiv.style.padding = '20px';
    rocketDiv.style.background = 'white';
    rocketDiv.style.boxShadow = '0 2px 8px rgba(0,0,0,0.1)';
    rocketDiv.style.transition = 'transform 0.2s, box-shadow 0.2s';
    rocketDiv.style.cursor = 'pointer';
    rocketDiv.onmouseenter = () => {
      rocketDiv.style.transform = 'translateY(-5px)';
      rocketDiv.style.boxShadow = '0 4px 12px rgba(0,0,0,0.2)';
    };
    rocketDiv.onmouseleave = () => {
      rocketDiv.style.transform = 'translateY(0)';
      rocketDiv.style.boxShadow = '0 2px 8px rgba(0,0,0,0.1)';
    };
    rocketDiv.innerHTML = `
      <div style="font-size: 48px; text-align: center; margin-bottom: 15px;">üöÄ</div>
      <div style="font-size: 16px; font-weight: bold; text-align: center; margin-bottom: 10px; color: #333;">Munici√≥n de Cohete</div>
      <div style="text-align: center; color: #666; margin-bottom: 15px; font-size: 14px;">üì¶ Cantidad: <strong>${rockets}</strong></div>
      <button onclick="sellMarketItem('rocket')" style="width: 100%; padding: 12px; background: linear-gradient(135deg, #89ff00 0%, #00bcd4 100%); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: bold; font-size: 14px; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">üí∞ Vender</button>
    `;
    sellInventory.appendChild(rocketDiv);
  }
  
  // Agregar bombarderos
  if (bombers > 0) {
    const bomberDiv = document.createElement('div');
    bomberDiv.style.border = '2px solid #4169E1';
    bomberDiv.style.borderRadius = '10px';
    bomberDiv.style.padding = '20px';
    bomberDiv.style.background = 'white';
    bomberDiv.style.boxShadow = '0 2px 8px rgba(0,0,0,0.1)';
    bomberDiv.style.transition = 'transform 0.2s, box-shadow 0.2s';
    bomberDiv.style.cursor = 'pointer';
    bomberDiv.onmouseenter = () => {
      bomberDiv.style.transform = 'translateY(-5px)';
      bomberDiv.style.boxShadow = '0 4px 12px rgba(0,0,0,0.2)';
    };
    bomberDiv.onmouseleave = () => {
      bomberDiv.style.transform = 'translateY(0)';
      bomberDiv.style.boxShadow = '0 2px 8px rgba(0,0,0,0.1)';
    };
    bomberDiv.innerHTML = `
      <div style="font-size: 48px; text-align: center; margin-bottom: 15px;">‚úàÔ∏è</div>
      <div style="font-size: 16px; font-weight: bold; text-align: center; margin-bottom: 10px; color: #333;">Avi√≥n Bombardero</div>
      <div style="text-align: center; color: #666; margin-bottom: 15px; font-size: 14px;">üì¶ Cantidad: <strong>${bombers}</strong></div>
      <button onclick="sellMarketItem('bomber')" style="width: 100%; padding: 12px; background: linear-gradient(135deg, #89ff00 0%, #00bcd4 100%); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: bold; font-size: 14px; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">üí∞ Vender</button>
    `;
    sellInventory.appendChild(bomberDiv);
  }
}

async function loadMyMarketOffers() {
  const offersSnap = await get(ref(db, 'market'));
  const myOffers = $('marketMyOffers');
  myOffers.innerHTML = '';
  
  if (!offersSnap.exists()) {
    myOffers.innerHTML = '<p style="text-align: center; color: #666; padding: 40px; grid-column: 1/-1;">No tienes ofertas activas</p>';
    return;
  }
  
  const offers = offersSnap.val();
  const myOffersList = Object.entries(offers).filter(([_, offer]) => offer.seller === state.user);
  
  if (myOffersList.length === 0) {
    myOffers.innerHTML = '<p style="text-align: center; color: #666; padding: 40px; grid-column: 1/-1;">No tienes ofertas activas</p>';
    return;
  }
  
  myOffersList.forEach(([offerId, offer]) => {
    const offerDiv = document.createElement('div');
    offerDiv.style.border = '3px solid #4CAF50';
    offerDiv.style.borderRadius = '10px';
    offerDiv.style.padding = '20px';
    offerDiv.style.background = 'linear-gradient(135deg, #f0fff4 0%, #e8f5e9 100%)';
    offerDiv.style.boxShadow = '0 2px 8px rgba(76, 175, 80, 0.3)';
    offerDiv.style.transition = 'transform 0.2s, box-shadow 0.2s';
    offerDiv.onmouseenter = () => {
      offerDiv.style.transform = 'translateY(-5px)';
      offerDiv.style.boxShadow = '0 4px 12px rgba(76, 175, 80, 0.4)';
    };
    offerDiv.onmouseleave = () => {
      offerDiv.style.transform = 'translateY(0)';
      offerDiv.style.boxShadow = '0 2px 8px rgba(76, 175, 80, 0.3)';
    };
    
    const itemName = ITEM_NAMES[offer.item] || offer.item;
    const emoji = itemName.split(' ')[0];
    const name = itemName.split(' ').slice(1).join(' ');
    
    offerDiv.innerHTML = `
      <div style="font-size: 48px; text-align: center; margin-bottom: 15px;">${emoji}</div>
      <div style="font-size: 16px; font-weight: bold; text-align: center; margin-bottom: 15px; color: #2e7d32;">${name}</div>
      <div style="background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%); color: #000; font-size: 20px; font-weight: bold; padding: 12px; border-radius: 8px; text-align: center; margin-bottom: 15px; box-shadow: 0 2px 4px rgba(0,0,0,0.2);">üí∞ ${offer.price} Oro</div>
      <button onclick="cancelMarketOffer('${offerId}', '${offer.item}')" style="width: 100%; padding: 12px; background: linear-gradient(135deg, #ff0000 0%, #8b0000 100%); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: bold; font-size: 14px; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">üóëÔ∏è Cancelar Oferta</button>
    `;
    myOffers.appendChild(offerDiv);
  });
}

window.sellMarketItem = async function(item) {
  const price = prompt(`¬øA qu√© precio quieres vender ${ITEM_NAMES[item] || item}? (en oro)`);
  if (!price || isNaN(price) || parseInt(price) <= 0) return alert('Precio inv√°lido');
  
  loading(true);
  
  // Verificar que el usuario tiene el item
  const inventorySnap = await get(ref(db, `users/${state.user}/inventory`));
  if (!inventorySnap.exists()) {
    loading(false);
    return alert('No tienes este objeto');
  }
  
  const inventory = inventorySnap.val();
  let hasItem = false;
  
  if (item === 'rocket') {
    if ((inventory.rockets || 0) > 0) {
      hasItem = true;
      await set(ref(db, `users/${state.user}/inventory/rockets`), (inventory.rockets || 0) - 1);
    }
  } else if (item === 'bomber') {
    if ((inventory.bombers || 0) > 0) {
      hasItem = true;
      await set(ref(db, `users/${state.user}/inventory/bombers`), (inventory.bombers || 0) - 1);
    }
  } else {
    const items = inventory.items || [];
    if (items.includes(item)) {
      hasItem = true;
      items.splice(items.indexOf(item), 1);
      await set(ref(db, `users/${state.user}/inventory/items`), items);
    }
  }
  
  if (!hasItem) {
    loading(false);
    return alert('No tienes este objeto');
  }
  
  // Cancelar modo de colocaci√≥n si estaba activo
  if (state.placing === item || state.placing === 'statue' || state.placing === 'flower') {
    state.placing = null;
  }
  
  // Crear oferta en el mercado
  const offerId = Date.now() + '_' + state.user;
  await set(ref(db, `market/${offerId}`), {
    seller: state.user,
    item: item,
    price: parseInt(price),
    timestamp: Date.now()
  });
  
  alert('¬°Oferta publicada en el mercado!');
  await loadMarketSellInventory();
  loading(false);
};

window.buyMarketItem = async function(offerId, price) {
  if (state.resources.gold < price) return alert(`Necesitas ${price} de oro. Tienes ${state.resources.gold}.`);
  
  if (!confirm(`¬øComprar este objeto por ${price} oro?`)) return;
  
  loading(true);
  
  // Obtener la oferta
  const offerSnap = await get(ref(db, `market/${offerId}`));
  if (!offerSnap.exists()) {
    loading(false);
    return alert('Esta oferta ya no est√° disponible');
  }
  
  const offer = offerSnap.val();
  
  // Transferir oro
  state.resources.gold -= price;
  await set(ref(db, `users/${state.user}/resources/gold`), state.resources.gold);
  
  const sellerGoldSnap = await get(ref(db, `users/${offer.seller}/resources/gold`));
  const sellerGold = (sellerGoldSnap.val() || 0) + price;
  await set(ref(db, `users/${offer.seller}/resources/gold`), sellerGold);
  
  // Transferir item
  const buyerInventorySnap = await get(ref(db, `users/${state.user}/inventory`));
  const buyerInventory = buyerInventorySnap.val() || { items: [], rockets: 0, bombers: 0 };
  
  if (offer.item === 'rocket') {
    buyerInventory.rockets = (buyerInventory.rockets || 0) + 1;
    await set(ref(db, `users/${state.user}/inventory/rockets`), buyerInventory.rockets);
  } else if (offer.item === 'bomber') {
    buyerInventory.bombers = (buyerInventory.bombers || 0) + 1;
    await set(ref(db, `users/${state.user}/inventory/bombers`), buyerInventory.bombers);
  } else {
    buyerInventory.items = buyerInventory.items || [];
    buyerInventory.items.push(offer.item);
    await set(ref(db, `users/${state.user}/inventory/items`), buyerInventory.items);
  }
  
  // Eliminar oferta del mercado
  await set(ref(db, `market/${offerId}`), null);
  
  alert('¬°Compra realizada con √©xito!');
  $('marketGold').textContent = state.resources.gold;
  await loadMarketOffers();
  loading(false);
};

window.cancelMarketOffer = async function(offerId, item) {
  if (!confirm('¬øCancelar esta oferta? El objeto volver√° a tu inventario.')) return;
  
  loading(true);
  
  // Devolver item al inventario
  const inventorySnap = await get(ref(db, `users/${state.user}/inventory`));
  const inventory = inventorySnap.val() || { items: [], rockets: 0, bombers: 0 };
  
  if (item === 'rocket') {
    inventory.rockets = (inventory.rockets || 0) + 1;
    await set(ref(db, `users/${state.user}/inventory/rockets`), inventory.rockets);
  } else if (item === 'bomber') {
    inventory.bombers = (inventory.bombers || 0) + 1;
    await set(ref(db, `users/${state.user}/inventory/bombers`), inventory.bombers);
  } else {
    inventory.items = inventory.items || [];
    inventory.items.push(item);
    await set(ref(db, `users/${state.user}/inventory/items`), inventory.items);
  }
  
  // Eliminar oferta del mercado
  await set(ref(db, `market/${offerId}`), null);
  
  alert('Oferta cancelada. El objeto ha vuelto a tu inventario.');
  await loadMyMarketOffers();
  loading(false);
};

// Shop Functions
$('buyMineBtn').onclick = async () => {
  if (state.buildings.mines.length >= 2) return alert('Ya tienes el m√°ximo de minas (2)');
  if (state.resources.gold < 50) return alert(`Necesitas 50 de oro. Tienes ${state.resources.gold}.`);
  state.resources.gold -= 50;
  await set(ref(db, `users/${state.user}/resources`), {gold: state.resources.gold, lastUpdate: Date.now()});
  updateUI();
  state.placing = 'mine';
  hide(modal('shop'));
  alert('Haz click en una celda verde para colocar la mina');
};
$('buyRocketLauncherBtn').onclick = async () => {
  if (state.buildings.rocketLaunchers.length >= 1) return alert('Ya tienes el m√°ximo de lanza cohetes (1)');
  if (state.resources.gold < 2000) return alert(`Necesitas 2000 de oro. Tienes ${state.resources.gold}.`);
  state.resources.gold -= 2000;
  await set(ref(db, `users/${state.user}/resources`), {gold: state.resources.gold, lastUpdate: Date.now()});
  updateUI();
  state.placing = 'rocketLauncher';
  hide(modal('shop'));
  alert('Haz click en una celda verde para colocar el lanza cohetes');
};
$('buyAATurretBtn').onclick = async () => {
  if (state.buildings.aaTurrets.length >= 2) return alert('Ya tienes el m√°ximo de torretas anti-a√©reas (2)');
  if (state.resources.gold < 1800) return alert(`Necesitas 1800 de oro. Tienes ${state.resources.gold}.`);
  state.resources.gold -= 1800;
  await set(ref(db, `users/${state.user}/resources`), {gold: state.resources.gold, lastUpdate: Date.now()});
  updateUI();
  state.placing = 'aaTurret';
  hide(modal('shop'));
  alert('Haz click en una celda verde para colocar la torreta anti-a√©rea');
};
$('buyDeflectorTowerBtn').onclick = async () => {
  // Verificar si ya tiene el m√°ximo
  if (state.buildings.deflectorTowers.length >= 1) return alert('Ya tienes el m√°ximo de torres desviadoras (1)');
  
  // Verificar oro
  if (state.resources.gold < 1500) return alert(`Necesitas 1500 de oro. Tienes ${state.resources.gold}.`);
  
  // Verificar stock global
  const stockSnap = await get(ref(db, 'globalShop/deflectorTower/stock'));
  const stock = stockSnap.exists() ? stockSnap.val() : 5;
  
  if (stock <= 0) return alert('¬°Agotado! No hay m√°s Torres Desviadoras en stock.');
  
  // Usar transacci√≥n para reducir stock
  const stockRef = ref(db, 'globalShop/deflectorTower/stock');
  const result = await runTransaction(stockRef, (currentStock) => {
    if (currentStock === null) return 5;
    if (currentStock <= 0) return;
    return currentStock - 1;
  });
  
  if (!result.committed) return alert('Error al comprar. Intenta de nuevo.');
  
  // Deducir oro
  state.resources.gold -= 1500;
  await set(ref(db, `users/${state.user}/resources`), {gold: state.resources.gold, lastUpdate: Date.now()});
  
  // Cargar inventario actual y agregar torre
  const inventorySnap = await get(ref(db, `users/${state.user}/inventory/items`));
  const currentInventory = inventorySnap.exists() ? inventorySnap.val() : [];
  currentInventory.push('deflectorTower');
  
  // Guardar inventario actualizado
  await set(ref(db, `users/${state.user}/inventory/items`), currentInventory);
  state.inventory = currentInventory;
  
  updateUI();
  alert('üõ°Ô∏è Torre Desviadora comprada! Revisa tu inventario para colocarla.');
};
$('buyBomberPlaneBtn').onclick = async () => {
  // Verificar oro
  if (state.resources.gold < 2500) return alert(`Necesitas 2500 de oro. Tienes ${state.resources.gold}.`);
  
  // Verificar stock global
  const stockSnap = await get(ref(db, 'globalShop/bomberPlane/stock'));
  const stock = stockSnap.exists() ? stockSnap.val() : 8;
  
  if (stock <= 0) return alert('¬°Agotado! No hay m√°s Aviones Bombarderos en stock.');
  
  // Usar transacci√≥n para reducir stock
  const stockRef = ref(db, 'globalShop/bomberPlane/stock');
  const result = await runTransaction(stockRef, (currentStock) => {
    if (currentStock === null) return 8;
    if (currentStock <= 0) return;
    return currentStock - 1;
  });
  
  if (!result.committed) return alert('Error al comprar. Intenta de nuevo.');
  
  // Deducir oro
  state.resources.gold -= 2500;
  await set(ref(db, `users/${state.user}/resources`), {gold: state.resources.gold, lastUpdate: Date.now()});
  
  // Incrementar cantidad de aviones bombarderos
  const bomberSnap = await get(ref(db, `users/${state.user}/inventory/bomberPlanes`));
  const bomberCount = bomberSnap.exists() ? bomberSnap.val() : 0;
  await set(ref(db, `users/${state.user}/inventory/bomberPlanes`), bomberCount + 1);
  
  updateUI();
  alert('‚úàÔ∏è Avi√≥n Bombardero comprado! √ösalo desde el men√∫ de ataque.');
};
$('buySuperRocketLauncherGlobalBtn').onclick = async () => {
  // Verificar si ya tiene el m√°ximo
  if (state.buildings.superRocketLaunchers.length >= 1) return alert('Ya tienes el m√°ximo de Super Lanzadores (1)');
  
  // Verificar oro
  if (state.resources.gold < 10000) return alert(`Necesitas 10000 de oro. Tienes ${state.resources.gold}.`);
  
  // Verificar stock global
  const stockSnap = await get(ref(db, 'globalShop/superRocketLauncher/stock'));
  const stock = stockSnap.exists() ? stockSnap.val() : 3;
  
  if (stock <= 0) return alert('¬°Agotado! No hay m√°s Super Lanzadores en stock.');
  
  // Usar transacci√≥n para reducir stock
  const stockRef = ref(db, 'globalShop/superRocketLauncher/stock');
  const result = await runTransaction(stockRef, (currentStock) => {
    if (currentStock === null) return 3;
    if (currentStock <= 0) return;
    return currentStock - 1;
  });
  
  if (!result.committed) return alert('Error al comprar. Intenta de nuevo.');
  
  // Deducir oro
  state.resources.gold -= 10000;
  await set(ref(db, `users/${state.user}/resources`), {gold: state.resources.gold, lastUpdate: Date.now()});
  
  // Cargar inventario actual y agregar Super Lanzador
  const inventorySnap = await get(ref(db, `users/${state.user}/inventory/items`));
  const currentInventory = inventorySnap.exists() ? inventorySnap.val() : [];
  currentInventory.push('superRocketLauncher');
  
  // Guardar inventario actualizado
  await set(ref(db, `users/${state.user}/inventory/items`), currentInventory);
  state.inventory = currentInventory;
  
  updateUI();
  alert('üí• SUPER LANZADOR comprado! Revisa tu inventario para colocarlo. ‚ö†Ô∏è RECUERDA: Da√±a tu aldea al lanzar.');
};
// Funci√≥n para calcular el precio de la pala seg√∫n el nivel
function getShovelPrice(level) {
  const basePrices = {
    1: 50,      // x1: 1 celda
    5: 250,     // x5: 3x3 √°rea
    10: 1000,   // x10: 5x5 √°rea
    15: 3000,   // x15: 7x7 √°rea
    25: 7000    // x25: √°rea grande
  };
  return basePrices[level] || 50;
}

// Manejar selecci√≥n de nivel de pala
document.addEventListener('click', (e) => {
  if (e.target.classList.contains('shovel-level-btn')) {
    const level = parseInt(e.target.dataset.level);
    state.shovelLevel = level;
    
    // Actualizar estilos de botones
    document.querySelectorAll('.shovel-level-btn').forEach(btn => {
      btn.classList.remove('active');
      btn.style.border = '2px solid #ccc';
      btn.style.fontWeight = 'normal';
      btn.style.color = '#333';
    });
    
    e.target.classList.add('active');
    e.target.style.border = '2px solid #4CAF50';
    e.target.style.fontWeight = 'bold';
    e.target.style.color = '#333';
    
    // Actualizar precio
    const price = getShovelPrice(level);
    $('shovelCost').textContent = `üí∞ ${price} Oro`;
  }
});

$('buyShovelBtn').onclick = async () => {
  const price = getShovelPrice(state.shovelLevel);
  
  if (state.resources.gold < price) return alert(`Necesitas ${price} de oro. Tienes ${state.resources.gold}.`);
  
  state.resources.gold -= price;
  await set(ref(db, `users/${state.user}/resources`), {gold: state.resources.gold, lastUpdate: Date.now()});
  updateUI();
  
  const items = (await get(ref(db, `users/${state.user}/inventory/items`))).val() || [];
  items.push(`shovel_${state.shovelLevel}`);
  await set(ref(db, `users/${state.user}/inventory/items`), items);
  
  hide(modal('shop'));
  alert(`¬°Pala x${state.shovelLevel} comprada! A√±adida a tu inventario.`);
};
$('buyStatueBtn').onclick = async () => {
  loading(true);
  try {
    // Obtener el oro actual desde Firebase
    const goldSnap = await get(ref(db, `users/${state.user}/resources`));
    const gold = goldSnap.exists() ? (goldSnap.val().gold || 0) : 0;
    
    if (gold < 500) {
      alert(`Necesitas 500 de oro. Tienes ${gold}.`);
      loading(false);
      return;
    }
   
    const result = await runTransaction(ref(db, 'globalShop/statue'), data => {
      // Si no hay datos, inicializar con stock 0
      if (!data) {
        return {stock: 0};
      }
      
      // Verificar si hay stock disponible
      const currentStock = data.stock || 0;
      if (currentStock <= 0) {
        // Abortar la transacci√≥n retornando undefined
        return;
      }
      
      // Decrementar el stock
      return {stock: currentStock - 1};
    });
   
    if (!result.committed) {
      alert('Lo sentimos, el art√≠culo est√° agotado.');
      loading(false);
      return;
    }
   
    // Actualizar el oro en Firebase
    const newGold = gold - 500;
    await set(ref(db, `users/${state.user}/resources`), {gold: newGold, lastUpdate: Date.now()});
    state.resources.gold = newGold;
    updateUI();
   
    const items = (await get(ref(db, `users/${state.user}/inventory/items`))).val() || [];
    items.push('statue');
    await set(ref(db, `users/${state.user}/inventory/items`), items);
   
    alert('¬°Compra exitosa! La estatua Moai ha sido a√±adida a tu inventario.');
  } catch(e) {
    alert('Error al comprar: ' + e.message);
  }
  loading(false);
};
$('buyRocketAmmoBtn').onclick = async () => {
  loading(true);
  try {
    // Obtener el oro actual desde Firebase
    const goldSnap = await get(ref(db, `users/${state.user}/resources`));
    const gold = goldSnap.exists() ? (goldSnap.val().gold || 0) : 0;
    
    if (gold < 3000) {
      alert(`Necesitas 3000 de oro. Tienes ${gold}.`);
      loading(false);
      return;
    }
   
    const result = await runTransaction(ref(db, 'globalShop/rocketAmmo'), data => {
      // Si no hay datos, inicializar con stock 0
      if (!data) {
        return {stock: 0};
      }
      
      // Verificar si hay stock disponible
      const currentStock = data.stock || 0;
      if (currentStock <= 0) {
        // Abortar la transacci√≥n retornando undefined
        return;
      }
      
      // Decrementar el stock
      return {stock: currentStock - 1};
    });
   
    if (!result.committed) {
      alert('Lo sentimos, los cohetes est√°n agotados.');
      loading(false);
      return;
    }
   
    // Actualizar el oro en Firebase
    const newGold = gold - 3000;
    await set(ref(db, `users/${state.user}/resources`), {gold: newGold, lastUpdate: Date.now()});
    state.resources.gold = newGold;
    updateUI();
   
    const currentAmmo = (await get(ref(db, `users/${state.user}/inventory/rocketAmmo`))).val() || 0;
    await set(ref(db, `users/${state.user}/inventory/rocketAmmo`), currentAmmo + 1);
   
    alert('¬°Compra exitosa! Has comprado 1 cohete.');
  } catch(e) {
    alert('Error al comprar: ' + e.message);
  }
  loading(false);
};
$('buySuperRocketAmmoBtn').onclick = async () => {
  loading(true);
  try {
    // Obtener el oro actual desde Firebase
    const goldSnap = await get(ref(db, `users/${state.user}/resources`));
    const gold = goldSnap.exists() ? (goldSnap.val().gold || 0) : 0;
    
    if (gold < 8000) {
      alert(`Necesitas 8000 de oro. Tienes ${gold}.`);
      loading(false);
      return;
    }
   
    const result = await runTransaction(ref(db, 'globalShop/superRocketAmmo'), data => {
      // Si no hay datos, inicializar con stock 0
      if (!data) {
        return {stock: 0};
      }
      
      // Verificar si hay stock disponible
      const currentStock = data.stock || 0;
      if (currentStock <= 0) {
        // Abortar la transacci√≥n retornando undefined
        return;
      }
      
      // Decrementar el stock
      return {stock: currentStock - 1};
    });
   
    if (!result.committed) {
      alert('Lo sentimos, los Super Cohetes est√°n agotados.');
      loading(false);
      return;
    }
   
    // Actualizar el oro en Firebase
    const newGold = gold - 8000;
    await set(ref(db, `users/${state.user}/resources`), {gold: newGold, lastUpdate: Date.now()});
    state.resources.gold = newGold;
    updateUI();
   
    const currentAmmo = (await get(ref(db, `users/${state.user}/inventory/superRocketAmmo`))).val() || 0;
    await set(ref(db, `users/${state.user}/inventory/superRocketAmmo`), currentAmmo + 1);
   
    alert('üí• ¬°Compra exitosa! Has comprado 1 SUPER COHETE. ¬°√ösalo con precauci√≥n!');
  } catch(e) {
    alert('Error al comprar: ' + e.message);
  }
  loading(false);
};
$('buyFlowerBtn').onclick = async () => {
  loading(true);
  try {
    // Obtener el oro actual desde Firebase
    const goldSnap = await get(ref(db, `users/${state.user}/resources`));
    const gold = goldSnap.exists() ? (goldSnap.val().gold || 0) : 0;
    
    if (gold < 200) {
      alert(`Necesitas 200 de oro. Tienes ${gold}.`);
      loading(false);
      return;
    }
   
    const result = await runTransaction(ref(db, 'globalShop/flower'), data => {
      // Si no hay datos, inicializar con stock 0
      if (!data) {
        return {stock: 0};
      }
      
      // Verificar si hay stock disponible
      const currentStock = data.stock || 0;
      if (currentStock <= 0) {
        // Abortar la transacci√≥n retornando undefined
        return;
      }
      
      // Decrementar el stock
      return {stock: currentStock - 1};
    });
   
    if (!result.committed) {
      alert('Lo sentimos, las flores est√°n agotadas.');
      loading(false);
      return;
    }
   
    // Actualizar el oro en Firebase
    const newGold = gold - 200;
    await set(ref(db, `users/${state.user}/resources`), {gold: newGold, lastUpdate: Date.now()});
    state.resources.gold = newGold;
    updateUI();
   
    const items = (await get(ref(db, `users/${state.user}/inventory/items`))).val() || [];
    items.push('flower');
    await set(ref(db, `users/${state.user}/inventory/items`), items);
   
    alert('¬°Compra exitosa! La flor decorativa ha sido a√±adida a tu inventario.');
  } catch(e) {
    alert('Error al comprar: ' + e.message);
  }
  loading(false);
};
// Attack Modal
$('closeAttack').onclick = async () => {
  hide(modal('attack'));
  if (state.currentVillage.id) await set(ref(db, `villages/${state.currentVillage.id}/underAttack`), false);
};
document.querySelectorAll('.attack-option').forEach(btn => {
  btn.onclick = async () => {
    const type = btn.dataset.attack;
    hide(modal('attack'));
    loading(true);
   
    if (type === 'rocket') {
      // Verificar si el usuario tiene munici√≥n de cohetes
      const rocketAmmoSnap = await get(ref(db, `users/${state.user}/inventory/rocketAmmo`));
      const rocketAmmo = rocketAmmoSnap.exists() ? rocketAmmoSnap.val() : 0;
      
      if (rocketAmmo <= 0) {
        alert('¬°Necesitas munici√≥n de cohetes para realizar este ataque! Compra cohetes en la tienda global.');
        await set(ref(db, `villages/${state.currentVillage.id}/underAttack`), false);
        loading(false);
        return;
      }
      
      state.attacking = true;
      state.placing = 'rocket_attack';
      loading(false);
      alert('Haz click en una celda para lanzar el cohete (7x7)');
      return;
    }
    
    if (type === 'superRocket') {
      // Verificar si el usuario tiene munici√≥n de super cohetes
      const superRocketAmmoSnap = await get(ref(db, `users/${state.user}/inventory/superRocketAmmo`));
      const superRocketAmmo = superRocketAmmoSnap.exists() ? superRocketAmmoSnap.val() : 0;
      
      if (superRocketAmmo <= 0) {
        alert('¬°Necesitas munici√≥n de SUPER COHETES para realizar este ataque! C√≥mprala en la tienda global.');
        await set(ref(db, `villages/${state.currentVillage.id}/underAttack`), false);
        loading(false);
        return;
      }
      
      state.attacking = true;
      state.placing = 'super_rocket_attack';
      loading(false);
      alert('üí• Haz click en una celda para lanzar el SUPER COHETE (15x15) ‚ö†Ô∏è DA√ëAR√Å TU ALDEA AL DESPEGAR');
      return;
    }
    
    if (type === 'bomber') {
      // Verificar si el usuario tiene aviones bombarderos
      const bomberSnap = await get(ref(db, `users/${state.user}/inventory/bomberPlanes`));
      const bomberCount = bomberSnap.exists() ? bomberSnap.val() : 0;
      
      if (bomberCount <= 0) {
        alert('¬°Necesitas un Avi√≥n Bombardero! C√≥mpralo en la tienda global.');
        await set(ref(db, `villages/${state.currentVillage.id}/underAttack`), false);
        loading(false);
        return;
      }
      
      state.attacking = true;
      state.placing = 'bomber_attack';
      loading(false);
      alert('Haz click en una celda para iniciar el bombardeo en l√≠nea recta');
      return;
    }
    
    const cost = 100;
    const snap = await get(ref(db, `users/${state.user}/resources`));
    let gold = snap.exists() ? snap.val().gold : 0;
   
    if (gold < cost) {
      alert(`No tienes suficiente oro (necesitas ${cost}).`);
      await set(ref(db, `villages/${state.currentVillage.id}/underAttack`), false);
      loading(false);
      return;
    }
   
    gold -= cost;
    await set(ref(db, `users/${state.user}/resources`), {gold, lastUpdate: Date.now()});
   
    if (type === 'rob') {
      const vSnap = await get(ref(db, `users/${state.currentVillage.owner}/resources`));
      let vGold = vSnap.exists() ? vSnap.val().gold : 0;
      const steal = Math.min(50, Math.floor(vGold * 0.1));
     
      if (steal <= 0) {
        alert('No hay suficiente oro para robar.');
        await set(ref(db, `villages/${state.currentVillage.id}/underAttack`), false);
        loading(false);
        return;
      }
     
      gold += steal;
      vGold -= steal;
     
      await set(ref(db, `users/${state.user}/resources`), {gold, lastUpdate: Date.now()});
      await set(ref(db, `users/${state.currentVillage.owner}/resources`), {gold: vGold, lastUpdate: Date.now()});
      
      // Dar XP al atacante (state.user), no al due√±o de la aldea
      const attackerLevelSnap = await get(ref(db, `users/${state.user}/level`));
      if (attackerLevelSnap.exists()) {
        let attackerLevel = attackerLevelSnap.val();
        attackerLevel.xp = (attackerLevel.xp || 0) + 20;
        
        // Verificar si sube de nivel
        while (attackerLevel.xp >= attackerLevel.needed && attackerLevel.level < 20) {
          attackerLevel.xp -= attackerLevel.needed;
          attackerLevel.level++;
          attackerLevel.needed = attackerLevel.level * 100;
        }
        
        if (attackerLevel.level >= 20) attackerLevel.xp = Math.min(attackerLevel.xp, attackerLevel.needed - 1);
        
        await set(ref(db, `users/${state.user}/level`), attackerLevel);
      }
     
      state.resources.gold = vGold;
      updateUI();
     
      // Mostrar notificaci√≥n de XP y oro robado
      showXPNotification(20, window.innerWidth / 2 - 50, window.innerHeight / 2, `+20 XP | +${steal} üí∞`);
      
      await set(ref(db, `villages/${state.currentVillage.id}/underAttack`), false);
      loading(false);
    } else {
      state.attacking = true;
      state.placing = 'bomb';
      loading(false);
      alert('Haz click en una celda para lanzar la bomba (3x3)');
    }
  };
});
// Achievements
async function unlockAchievement(id) {
  if (!state.user || state.achievements[id]) return;
  state.achievements[id] = true;
  await set(ref(db, `users/${state.user}/achievements/${id}`), true);
 
  const a = ACHIEVEMENTS[id];
  if (a) {
    alert(`üèÜ ¬°Logro Desbloqueado!\n${a.name}\n${a.desc}\nRecompensa: ${a.reward}`);
   
    if (a.reward.includes('XP')) {
      await addXP(parseInt(a.reward.match(/\d+/)[0]));
    } else if (a.reward.includes('Oro')) {
      const amt = parseInt(a.reward.match(/\d+/)[0]);
      state.resources.gold += amt;
      await set(ref(db, `users/${state.user}/resources`), {gold: state.resources.gold, lastUpdate: Date.now()});
      updateUI();
    }
  }
}
async function checkAchievements() {
  if (!state.user) return;
  if (state.level.level >= 5 && !state.achievements.level5) await unlockAchievement('level5');
  if (state.level.level >= 10 && !state.achievements.level10) await unlockAchievement('level10');
  if (state.resources.gold >= 500 && !state.achievements.rich) await unlockAchievement('rich');
  if (state.resources.gold >= 1000 && !state.achievements.millionaire) await unlockAchievement('millionaire');
  if (state.buildings.mines.length >= 2 && !state.achievements.maxMines) await unlockAchievement('maxMines');
  if (state.buildings.rocketLaunchers.length >= 1 && !state.achievements.rocketLauncher) await unlockAchievement('rocketLauncher');
}
$('achievementsButton').onclick = $('islandAchievementsButton').onclick = async () => {
  show(modal('achievements'));
  const snap = await get(ref(db, `users/${state.user}/achievements`));
  state.achievements = snap.exists() ? snap.val() : {};
 
  $('achievementsList').innerHTML = Object.values(ACHIEVEMENTS).map(a => {
    const unlocked = state.achievements[a.id];
    return `
      <div class="achievement-item ${unlocked ? 'unlocked' : ''}">
        <div class="achievement-icon">${a.icon}</div>
        <div class="achievement-info">
          <div class="achievement-name">${a.name}</div>
          <div class="achievement-desc">${a.desc}</div>
          <div class="achievement-reward">Recompensa: ${a.reward}</div>
        </div>
        <div class="achievement-status ${unlocked ? '' : 'locked'}">${unlocked ? '‚úÖ' : 'üîí'}</div>
      </div>
    `;
  }).join('');
};
// Top Players
$('topPlayersButton').onclick = async () => {
  loading(true);
  show(modal('topPlayers'));
 
  const snap = await get(ref(db, 'users'));
  if (!snap.exists()) {
    $('topPlayersList').innerHTML = '<div style="color:white;text-align:center;padding:20px">No hay jugadores todav√≠a</div>';
    loading(false);
    return;
  }
 
  const players = Object.entries(snap.val())
    .filter(([_, u]) => u.level)
    .map(([name, u]) => {
      const lvl = u.level.level || 1;
      const xp = u.level.xp || 0;
      return {name, level: lvl, xp, totalXP: ((lvl - 1) * lvl * 100 / 2) + xp};
    })
    .sort((a, b) => b.totalXP - a.totalXP)
    .slice(0, 10);
 
  $('topPlayersList').innerHTML = players.length ? players.map((p, i) => {
    const rank = i + 1;
    const cls = rank === 1 ? 'first' : rank === 2 ? 'second' : rank === 3 ? 'third' : '';
    return `
      <div class="top-player-item" onclick="visitPlayer('${p.name}')">
        <div class="top-player-rank ${cls}">${rank}</div>
        <div class="top-player-info">
          <div class="top-player-name">${p.name}</div>
          <div class="top-player-stats">Nivel ${p.level}</div>
        </div>
        <div class="top-player-xp">${Math.floor(p.totalXP)} XP</div>
      </div>
    `;
  }).join('') : '<div style="color:white;text-align:center;padding:20px">No hay jugadores todav√≠a</div>';
 
  loading(false);
};
window.visitPlayer = async name => {
  hide(modal('topPlayers'));
  loading(true);
  const snap = await get(ref(db, 'villages'));
  if (snap.exists()) {
    const village = Object.values(snap.val()).find(v => v.owner === name);
    if (village) openIsland(name);
    else alert(`${name} a√∫n no ha construido su aldea`);
  } else {
    alert(`${name} a√∫n no ha construido su aldea`);
  }
  loading(false);
};
// Inventory
$('inventoryButton').onclick = async () => {
  show(modal('inventory'));
  loading(true);
  const snap = await get(ref(db, `users/${state.user}/inventory/items`));
  state.inventory = snap.exists() ? snap.val() : [];
  
  const rocketAmmoSnap = await get(ref(db, `users/${state.user}/inventory/rocketAmmo`));
  const rocketAmmo = rocketAmmoSnap.exists() ? rocketAmmoSnap.val() : 0;
  loading(false);
 
  $('inventoryItems').innerHTML = state.inventory.length || rocketAmmo > 0 ? 
    (rocketAmmo > 0 ? `
      <div class="shop-item">
        <div class="shop-item-info">
          <div class="shop-item-name">üöÄ Cohetes</div>
          <div class="shop-item-desc">Municiones para el lanza cohetes</div>
          <div class="shop-item-desc">Cantidad: ${rocketAmmo}</div>
        </div>
      </div>
    ` : '') + 
    state.inventory.map((item, i) => {
      let info;
      if (item === 'statue') {
        info = {name: 'üóø Estatua Moai', desc: 'Estatua decorativa √∫nica'};
      } else if (item === 'flower') {
        info = {name: 'üå∏ Flor Decorativa', desc: 'Hermosa flor para decorar tu aldea'};
      } else if (item === 'deflectorTower') {
        info = {name: 'üõ°Ô∏è Torre Desviadora', desc: 'Desv√≠a cohetes enemigos al mar'};
      } else if (item === 'superRocketLauncher') {
        info = {name: 'üí• Super Lanzador', desc: 'Lanza Super Cohetes devastadores (15x15) ‚ö†Ô∏è Da√±a tu aldea'};
      } else if (item.startsWith('shovel_')) {
        const level = item.split('_')[1];
        info = {name: `üõ†Ô∏è Pala x${level}`, desc: `Repara hasta ${level} √°rea(s) da√±ada(s)`};
      } else {
        info = {name: 'üõ†Ô∏è Pala', desc: 'Repara √°reas da√±adas'};
      }
      return `
        <div class="shop-item">
          <div class="shop-item-info">
            <div class="shop-item-name">${info.name}</div>
            <div class="shop-item-desc">${info.desc}</div>
          </div>
          <button onclick="useItem(${i})">Usar</button>
        </div>
      `;
    }).join('') : '<div style="color:white;text-align:center;padding:20px">Inventario vac√≠o</div>';
};
window.useItem = i => {
  state.placing = state.inventory[i];
  hide(modal('inventory'));
  
  const isShovel = state.placing.startsWith('shovel');
  const isStatue = state.placing === 'statue';
  const isFlower = state.placing === 'flower';
  const isDeflectorTower = state.placing === 'deflectorTower';
  const isSuperRocketLauncher = state.placing === 'superRocketLauncher';
  const shovelLevel = isShovel ? state.placing.split('_')[1] : '1';
  
  if (isStatue) {
    alert('Haz click en una celda verde para colocar la estatua');
  } else if (isFlower) {
    alert('Haz click en una celda verde para colocar la flor');
  } else if (isDeflectorTower) {
    alert('Haz click en una celda verde para colocar la Torre Desviadora (protege contra cohetes en rango de 3 celdas)');
  } else if (isSuperRocketLauncher) {
    alert('‚ö†Ô∏è Haz click en una celda verde para colocar el SUPER LANZADOR. ¬°CUIDADO: Da√±a tu aldea al despegar!');
  } else if (isShovel) {
    alert(`Haz click en una celda da√±ada para reparar (Pala x${shovelLevel})`);
  } else {
    alert('Haz click en una celda da√±ada para reparar');
  }
};
// Login/Register
$('loginTab').onclick = () => {
  $('loginTab').classList.add('active');
  $('registerTab').classList.remove('active');
  $('loginForm').classList.add('active');
  $('registerForm').classList.remove('active');
};
$('registerTab').onclick = () => {
  $('registerTab').classList.add('active');
  $('loginTab').classList.remove('active');
  $('registerForm').classList.add('active');
  $('loginForm').classList.remove('active');
};
$('loginBtn').onclick = async () => {
  const user = $('loginUsername').value.trim();
  const pass = $('loginPassword').value;
 
  if (!user || !pass) {
    $('loginError').textContent = 'Por favor completa todos los campos';
    show($('loginError'));
    return;
  }
 
  loading(true);
  const snap = await get(ref(db, `accounts/${user}`));
 
  if (!snap.exists()) {
    $('loginError').textContent = 'Usuario no encontrado';
    show($('loginError'));
    loading(false);
    return;
  }
 
  if (snap.val().password !== pass) {
    $('loginError').textContent = 'Contrase√±a incorrecta';
    show($('loginError'));
    loading(false);
    return;
  }
 
  state.user = user;
  localStorage.setItem('currentUser', user);
  hide(modal('login'));
 
  const villSnap = await get(ref(db, 'villages'));
  if (villSnap.exists()) {
    state.hasBuilt = Object.values(villSnap.val()).some(v => v.owner === user);
  }
 
  const achSnap = await get(ref(db, `users/${user}/achievements`));
  state.achievements = achSnap.exists() ? achSnap.val() : {};
 
  if (!localStorage.getItem('tutorialCompleted')) {
    setTimeout(() => show(modal('tutorial')), 500);
  }
 
  loading(false);
};
$('registerBtn').onclick = async () => {
  const user = $('registerUsername').value.trim();
  const pass = $('registerPassword').value;
  const conf = $('registerPasswordConfirm').value;
 
  if (!user || !pass || !conf) {
    $('registerError').textContent = 'Por favor completa todos los campos';
    show($('registerError'));
    return;
  }
 
  if (user.length < 3) {
    $('registerError').textContent = 'El nombre debe tener al menos 3 caracteres';
    show($('registerError'));
    return;
  }
 
  if (pass.length < 6) {
    $('registerError').textContent = 'La contrase√±a debe tener al menos 6 caracteres';
    show($('registerError'));
    return;
  }
 
  if (pass !== conf) {
    $('registerError').textContent = 'Las contrase√±as no coinciden';
    show($('registerError'));
    return;
  }
 
  loading(true);
  const snap = await get(ref(db, `accounts/${user}`));
 
  if (snap.exists()) {
    $('registerError').textContent = 'Este nombre de usuario ya existe';
    show($('registerError'));
    loading(false);
    return;
  }
 
  await set(ref(db, `accounts/${user}`), {password: pass, createdAt: Date.now()});
 
  state.user = user;
  localStorage.setItem('currentUser', user);
  hide(modal('login'));
  loading(false);
 
  alert('¬°Cuenta creada exitosamente!');
  setTimeout(() => show(modal('tutorial')), 500);
};
$('logoutButton').onclick = () => {
  if (confirm('¬øSeguro que quieres cerrar sesi√≥n?')) {
    localStorage.removeItem('currentUser');
    location.reload();
  }
};
// Tutorial
$('tutorialNext').onclick = () => {
  if (state.tutorial.step < 6) {
    document.querySelector(`.tutorial-step[data-step="${state.tutorial.step}"]`).classList.remove('active');
    state.tutorial.step++;
    document.querySelector(`.tutorial-step[data-step="${state.tutorial.step}"]`).classList.add('active');
    $('tutorialCurrentStep').textContent = state.tutorial.step;
    $('tutorialPrev').style.display = 'block';
    if (state.tutorial.step === 6) $('tutorialNext').textContent = '¬°Empezar!';
  } else {
    hide(modal('tutorial'));
    localStorage.setItem('tutorialCompleted', 'true');
    state.tutorial.step = 1;
  }
};
$('tutorialPrev').onclick = () => {
  if (state.tutorial.step > 1) {
    document.querySelector(`.tutorial-step[data-step="${state.tutorial.step}"]`).classList.remove('active');
    state.tutorial.step--;
    document.querySelector(`.tutorial-step[data-step="${state.tutorial.step}"]`).classList.add('active');
    $('tutorialCurrentStep').textContent = state.tutorial.step;
    if (state.tutorial.step === 1) $('tutorialPrev').style.display = 'none';
    $('tutorialNext').textContent = 'Siguiente ‚Üí';
  }
};
// Navigation
$('backButton').onclick = () => {
  $('fade').style.opacity = 1;
  if (state.intervals.gold) {
    clearInterval(state.intervals.gold);
    state.intervals.gold = null;
  }
  state.placing = null;
  state.attacking = false;
  if (state.currentVillage.id) set(ref(db, `villages/${state.currentVillage.id}/underAttack`), false);
 
  setTimeout(() => {
    document.querySelector('.island-view').style.opacity = 0;
    document.querySelector('.island-view').style.pointerEvents = 'none';
    $('islandGridToggle').style.opacity = 0;
    $('islandGridToggle').style.pointerEvents = 'none';
    $('islandTextureToggle').style.opacity = 0;
    $('islandTextureToggle').style.pointerEvents = 'none';
    $('islandAchievementsButton').style.opacity = 0;
    $('islandAchievementsButton').style.pointerEvents = 'none';
    $('resourcesPanel').style.display = 'none';
    $('userInfoPanel').style.display = 'none';
    $('shopButton').style.display = 'none';
    $('inventoryButton').style.display = 'none';
    $('marketButton').style.display = 'none';
    $('attackButton').style.display = 'none';
    document.querySelector('.map-view').style.opacity = 1;
  }, 400);
 
  setTimeout(() => $('fade').style.opacity = 0, 900);
};
function transition(toIsland) {
  $('fade').style.opacity = 1;
 
  setTimeout(() => {
    if (toIsland) {
      document.querySelector('.map-view').style.opacity = 0;
      document.querySelector('.island-view').style.opacity = 1;
      document.querySelector('.island-view').style.pointerEvents = 'auto';
      $('islandGridToggle').style.opacity = 1;
      $('islandGridToggle').style.pointerEvents = 'auto';
      $('islandTextureToggle').style.opacity = 1;
      $('islandTextureToggle').style.pointerEvents = 'auto';
      $('islandAchievementsButton').style.opacity = 1;
      $('islandAchievementsButton').style.pointerEvents = 'auto';
      $('resourcesPanel').style.display = 'block';
      $('userInfoPanel').style.display = 'block';
    }
  }, 400);
 
  setTimeout(() => $('fade').style.opacity = 0, 900);
}
// Grid Toggle
$('gridToggle').onclick = () => {
  state.grids.main = !state.grids.main;
  $('mainGrid').classList.toggle('no-grid');
  $('gridToggle').textContent = state.grids.main ? 'Quitar Cuadr√≠cula' : 'Mostrar Cuadr√≠cula';
};
$('islandGridToggle').onclick = () => {
  state.grids.island = !state.grids.island;
  $('islandGrid').classList.toggle('no-grid');
  $('islandGridToggle').textContent = state.grids.island ? 'Quitar Cuadr√≠cula' : 'Mostrar Cuadr√≠cula';
};
// Texture Toggle (solo en vista de isla)
$('islandTextureToggle').onclick = () => {
  state.textureMode = !state.textureMode;
  document.body.classList.toggle('texture-mode');
  $('islandTextureToggle').textContent = state.textureMode ? 'üé® Normal' : 'üé® Texturas';
};
// Day/Night Toggle
$('dayNightToggle').onclick = () => {
  state.nightMode = !state.nightMode;
  document.body.classList.toggle('night-mode');
  $('dayNightToggle').textContent = state.nightMode ? '‚òÄÔ∏è' : 'üåô';
};
// Modal Close Buttons
$('closeShop').onclick = () => hide(modal('shop'));
$('closeInventory').onclick = () => hide(modal('inventory'));
$('closeMarket').onclick = () => {
  hide(modal('market'));
  // Bajar gradualmente el volumen de la m√∫sica antes de pausar
  const shopMusic = $('shopMusic');
  const fadeOutInterval = setInterval(() => {
    if (shopMusic.volume > 0.01) {
      shopMusic.volume = Math.max(0, shopMusic.volume - 0.02);
    } else {
      shopMusic.volume = 0.15; // Restaurar volumen para la pr√≥xima vez
      shopMusic.pause();
      clearInterval(fadeOutInterval);
    }
  }, 50); // Bajar cada 50ms
};
$('closeGlobalShop').onclick = () => {
  hide(modal('globalShop'));
  // Bajar gradualmente el volumen de la m√∫sica antes de pausar
  const shopMusic = $('shopMusic');
  const fadeOutInterval = setInterval(() => {
    if (shopMusic.volume > 0.01) {
      shopMusic.volume = Math.max(0, shopMusic.volume - 0.02);
    } else {
      shopMusic.volume = 0.15; // Restaurar volumen para la pr√≥xima vez
      shopMusic.pause();
      clearInterval(fadeOutInterval);
    }
  }, 50); // Bajar cada 50ms
};
$('closeTopPlayers').onclick = () => hide(modal('topPlayers'));
// Sistema de pesta√±as de la tienda global
document.querySelectorAll('.shop-tab').forEach(tab => {
  tab.onclick = () => {
    const targetTab = tab.dataset.tab;
    
    // Remover active de todas las pesta√±as y categor√≠as
    document.querySelectorAll('.shop-tab').forEach(t => t.classList.remove('active'));
    document.querySelectorAll('.shop-category').forEach(c => c.classList.remove('active'));
    
    // Activar pesta√±a y categor√≠a seleccionada
    tab.classList.add('active');
    document.getElementById(`shop-${targetTab}`).classList.add('active');
  };
});
$('closeAchievements').onclick = () => hide(modal('achievements'));
$('closeVillageOptions').onclick = () => hide(modal('villageOptions'));
$('viewVillageBtn').onclick = () => {
  hide(modal('villageOptions'));
  if (state.selectedVillage) {
    openIsland(state.selectedVillage.owner);
  }
};
$('spectateBtn').onclick = async () => {
  hide(modal('villageOptions'));
  if (state.selectedVillage) {
    await startSpectating(state.selectedVillage);
  }
};
$('shopButton').onclick = () => {
  show(modal('shop'));
  updateShop();
};
$('marketButton').onclick = async () => {
  if (!state.user) return alert('Debes iniciar sesi√≥n para acceder al mercado');
  await openMarket();
};
$('attackButton').onclick = async () => {
  show(modal('attack'));
  const snap = await get(ref(db, 'villages'));
  if (snap.exists()) {
    const village = Object.entries(snap.val()).find(([_, v]) => v.owner === state.currentVillage.owner);
    if (village) {
      state.currentVillage.id = village[0];
      await set(ref(db, `villages/${village[0]}/underAttack`), true);
    }
  }
};
$('globalShopButton').onclick = async () => {
  if (!state.user) return alert('Debes iniciar sesi√≥n para acceder a la tienda global');
 
  loading(true);
  
  // Cargar el oro actual del usuario desde Firebase
  const goldSnap = await get(ref(db, `users/${state.user}/resources`));
  if (goldSnap.exists()) {
    state.resources.gold = goldSnap.val().gold || 0;
  }
  
  // Inicializar stock si no existe
  let statueSnap = await get(ref(db, 'globalShop/statue'));
  if (!statueSnap.exists()) {
    await set(ref(db, 'globalShop/statue'), {stock: 10, visible: true});
    statueSnap = await get(ref(db, 'globalShop/statue'));
  }
  
  let rocketAmmoSnap = await get(ref(db, 'globalShop/rocketAmmo'));
  if (!rocketAmmoSnap.exists()) {
    await set(ref(db, 'globalShop/rocketAmmo'), {stock: 10, visible: true});
    rocketAmmoSnap = await get(ref(db, 'globalShop/rocketAmmo'));
  }
  
  let flowerSnap = await get(ref(db, 'globalShop/flower'));
  if (!flowerSnap.exists()) {
    await set(ref(db, 'globalShop/flower'), {stock: 15, visible: true});
    flowerSnap = await get(ref(db, 'globalShop/flower'));
  }
  
  let deflectorTowerSnap = await get(ref(db, 'globalShop/deflectorTower'));
  if (!deflectorTowerSnap.exists()) {
    await set(ref(db, 'globalShop/deflectorTower'), {stock: 5, visible: true});
    deflectorTowerSnap = await get(ref(db, 'globalShop/deflectorTower'));
  }
  
  let bomberPlaneSnap = await get(ref(db, 'globalShop/bomberPlane'));
  if (!bomberPlaneSnap.exists()) {
    await set(ref(db, 'globalShop/bomberPlane'), {stock: 8, visible: true});
    bomberPlaneSnap = await get(ref(db, 'globalShop/bomberPlane'));
  }
  
  let superRocketAmmoSnap = await get(ref(db, 'globalShop/superRocketAmmo'));
  if (!superRocketAmmoSnap.exists()) {
    await set(ref(db, 'globalShop/superRocketAmmo'), {stock: 5, visible: true});
    superRocketAmmoSnap = await get(ref(db, 'globalShop/superRocketAmmo'));
  }
  
  let superRocketLauncherSnap = await get(ref(db, 'globalShop/superRocketLauncher'));
  if (!superRocketLauncherSnap.exists()) {
    await set(ref(db, 'globalShop/superRocketLauncher'), {stock: 3, visible: true});
    superRocketLauncherSnap = await get(ref(db, 'globalShop/superRocketLauncher'));
  }
 
  const statueStock = statueSnap.val().stock || 0;
  const statueVisible = statueSnap.val().visible !== false;
  const rocketAmmoStock = rocketAmmoSnap.val().stock || 0;
  const rocketAmmoVisible = rocketAmmoSnap.val().visible !== false;
  const flowerStock = flowerSnap.val().stock || 0;
  const flowerVisible = flowerSnap.val().visible !== false;
  const deflectorTowerStock = deflectorTowerSnap.val().stock || 0;
  const deflectorTowerVisible = deflectorTowerSnap.val().visible !== false;
  const bomberPlaneStock = bomberPlaneSnap.val().stock || 0;
  const bomberPlaneVisible = bomberPlaneSnap.val().visible !== false;
  const superRocketAmmoStock = superRocketAmmoSnap.val().stock || 0;
  const superRocketAmmoVisible = superRocketAmmoSnap.val().visible !== false;
  const superRocketLauncherStock = superRocketLauncherSnap.val().stock || 0;
  const superRocketLauncherVisible = superRocketLauncherSnap.val().visible !== false;
  
  loading(false);
  show(modal('globalShop'));
  
  // Reproducir m√∫sica de la tienda
  const shopMusic = $('shopMusic');
  shopMusic.volume = 0.15; // Volumen al 15%
  shopMusic.currentTime = 0; // Reiniciar desde el inicio
  shopMusic.play().catch(err => console.log('Error al reproducir m√∫sica:', err));
 
  // Actualizar stock y visibilidad de items
  $('statueStock').textContent = statueStock;
  $('statueItem').style.display = statueVisible ? 'flex' : 'none';
  $('buyStatueBtn').disabled = statueStock <= 0;
  $('buyStatueBtn').textContent = statueStock <= 0 ? 'Agotado' : 'Comprar';
  
  $('rocketAmmoStock').textContent = rocketAmmoStock;
  $('rocketAmmoItem').style.display = rocketAmmoVisible ? 'flex' : 'none';
  $('buyRocketAmmoBtn').disabled = rocketAmmoStock <= 0;
  $('buyRocketAmmoBtn').textContent = rocketAmmoStock <= 0 ? 'Agotado' : 'Comprar';
  
  $('flowerStock').textContent = flowerStock;
  $('flowerItem').style.display = flowerVisible ? 'flex' : 'none';
  $('buyFlowerBtn').disabled = flowerStock <= 0;
  $('buyFlowerBtn').textContent = flowerStock <= 0 ? 'Agotado' : 'Comprar';
  
  $('deflectorTowerStock').textContent = deflectorTowerStock;
  $('deflectorTowerItem').style.display = deflectorTowerVisible ? 'flex' : 'none';
  $('buyDeflectorTowerBtn').disabled = deflectorTowerStock <= 0;
  $('buyDeflectorTowerBtn').textContent = deflectorTowerStock <= 0 ? 'Agotado' : 'Comprar';
  
  $('bomberPlaneStock').textContent = bomberPlaneStock;
  $('bomberPlaneItem').style.display = bomberPlaneVisible ? 'flex' : 'none';
  $('buyBomberPlaneBtn').disabled = bomberPlaneStock <= 0;
  $('buyBomberPlaneBtn').textContent = bomberPlaneStock <= 0 ? 'Agotado' : 'Comprar';
  
  $('superRocketAmmoStock').textContent = superRocketAmmoStock;
  $('superRocketAmmoItem').style.display = superRocketAmmoVisible ? 'flex' : 'none';
  $('buySuperRocketAmmoBtn').disabled = superRocketAmmoStock <= 0;
  $('buySuperRocketAmmoBtn').textContent = superRocketAmmoStock <= 0 ? 'Agotado' : 'Comprar';
  
  $('superRocketLauncherStock').textContent = superRocketLauncherStock;
  $('superRocketLauncherItem').style.display = superRocketLauncherVisible ? 'flex' : 'none';
  $('buySuperRocketLauncherGlobalBtn').disabled = superRocketLauncherStock <= 0;
  $('buySuperRocketLauncherGlobalBtn').textContent = superRocketLauncherStock <= 0 ? 'Agotado' : 'Comprar';
};
// Drag & Zoom
function setupDrag(viewport, world, view) {
  viewport.addEventListener('mousedown', e => {
    if (state.dragLocked) return; // Bloquear si hay un ataque en curso
    if (e.target === viewport || e.target === world || e.target.classList.contains('cell')) {
      state.drag.active = true;
      state.drag.moved = false;
      state.drag.startX = e.clientX - view.x;
      state.drag.startY = e.clientY - view.y;
      viewport.style.cursor = 'grabbing';
    }
  });
 
  viewport.addEventListener('mouseup', () => {
    state.drag.active = false;
    viewport.style.cursor = state.dragLocked ? 'default' : 'grab';
  });
 
  viewport.addEventListener('mouseleave', () => {
    state.drag.active = false;
    viewport.style.cursor = state.dragLocked ? 'default' : 'grab';
  });
 
  viewport.addEventListener('mousemove', e => {
    if (!state.drag.active || state.dragLocked) return;
    e.preventDefault();
   
    const dx = Math.abs(e.clientX - state.drag.startX - view.x);
    const dy = Math.abs(e.clientY - state.drag.startY - view.y);
    if (dx > 3 || dy > 3) state.drag.moved = true;
   
    view.x = e.clientX - state.drag.startX;
    view.y = e.clientY - state.drag.startY;
    updateTransform(view === state.view.main ? 'main' : 'island');
  });
 
  viewport.addEventListener('wheel', e => {
    e.preventDefault();
    const rect = viewport.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
   
    const beforeX = (mx - view.x) / view.scale;
    const beforeY = (my - view.y) / view.scale;
   
    const delta = e.deltaY < 0 ? 0.1 : -0.1;
    const newScale = Math.min(Math.max(view.scale + delta, 0.3), 3);
   
    const afterX = (mx - view.x) / newScale;
    const afterY = (my - view.y) / newScale;
   
    view.x += (afterX - beforeX) * newScale;
    view.y += (afterY - beforeY) * newScale;
    view.scale = newScale;
   
    updateTransform(view === state.view.main ? 'main' : 'island');
  });
}
function updateTransform(type) {
  const view = type === 'main' ? state.view.main : state.view.island;
  const world = type === 'main' ? $('mainWorld') : $('islandWorld');
  world.style.transform = `translate(${view.x}px, ${view.y}px) scale(${view.scale})`;
}
// Initialize
function init() {
  initMap();
  setupListeners();
  setupDrag($('mainViewport'), $('mainWorld'), state.view.main);
  setupDrag($('islandViewport'), $('islandWorld'), state.view.island);

  const saved = localStorage.getItem('currentUser');
  if (saved) {
    state.user = saved;
    hide(modal('login'));
   
    get(ref(db, 'villages')).then(snap => {
      if (snap.exists()) {
        state.hasBuilt = Object.values(snap.val()).some(v => v.owner === saved);
      }
    });
   
    get(ref(db, `users/${saved}/achievements`)).then(snap => {
      state.achievements = snap.exists() ? snap.val() : {};
    });
   
    if (!localStorage.getItem('tutorialCompleted')) {
      setTimeout(() => show(modal('tutorial')), 500);
    }
  } else {
    // Si no hay usuario guardado, mostrar el modal de login
    show(modal('login'));
  }

  state.view.main.x = ($('mainViewport').clientWidth - $('mainGrid').offsetWidth) / 2;
  state.view.main.y = ($('mainViewport').clientHeight - $('mainGrid').offsetHeight) / 2;
  updateTransform('main');
}
window.addEventListener('load', init);
</script>
</body>
</html>
